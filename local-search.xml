<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络八股</title>
    <link href="/2026/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/"/>
    <url>/2026/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<p>本文参考并整理自 JavaGuide，对计算机网络中常见的面试高频问题进行了内容精简与结构化梳理。在保证核心概念准确性的前提下，尽量压缩表述、突出关键点，并结合个人理解做了适当的记忆扩展，便于快速复习和长期理解。</p><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>物（比特传输）、链（帧编码、差错控制）、网（路由和寻址）、输（进程通信）、会、示（编码、加密）、用</p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p>接（链路和物理）、网、输、用（会话、表示、应用）</p><h3 id="网络分层的原因"><a href="#网络分层的原因" class="headerlink" title="网络分层的原因"></a>网络分层的原因</h3><ol><li>各层相互独立（无需关注其他层）</li><li>提高灵活性和可替换性（多答特性）</li><li>大问题化小（复杂问题拆解）</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><p>应用层：<strong>HTTP</strong>、SMTP（发邮件）、POP3&#x2F;IMAP（收邮件）、FTP（文件）、Telnet（登录）、SSH、RTP(实时传输，通常UDP)、<strong>DNS</strong>（域名解析，UDP）</p><p>传输层：<strong>TCP</strong>（面向连接、可靠）、<strong>UDP</strong>（无连接、最大可能交付）</p><p>网络层：<strong>IP</strong>、ARP（IP转MAC）、ICMP（控制报文）、NAT（网络地址转换）、OSPF（基于链路状态的内部网关协议）、RIP（基于距离向量的内部网关协议）、BGP（边界网关协议）</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="输入URL到页面展示（重点）"><a href="#输入URL到页面展示（重点）" class="headerlink" title="输入URL到页面展示（重点）"></a><strong>输入URL到页面展示（重点）</strong></h4><ol><li>输入指定网页的 URL。</li><li>DNS 协议，解析出 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h4><p><img src="/img/jiwang/http-status-code.png" alt="常见 HTTP 状态码"></p><h4 id="常见-HTTP-头字段包括："><a href="#常见-HTTP-头字段包括：" class="headerlink" title="常见 HTTP 头字段包括："></a><strong>常见 HTTP 头字段包括：</strong></h4><ul><li>Host、User-Agent、Accept、Authorization、Cookie</li></ul><h4 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 有什么区别？"></a><strong>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 有什么区别？</strong></h4><p><img src="/img/jiwang/http1.0-vs-http1.1.png" alt="HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 对比"></p><ul><li>前者<strong>短连接</strong>、后者<strong>长连接</strong></li><li>后者新增多种<strong>状态码</strong></li><li>引入更多<strong>缓存控制</strong>策略（提供更多缓存头字段如：Entity tag、If-Match）</li><li><strong>带宽</strong>，加入range头域，允许只请求资源的某个部分</li><li><strong>Host头</strong>，允许同一个IP托管多个域名，实现虚拟主机</li></ul><h4 id="HTTP-1-1-和-HTTP-2-0-有什么区别？（重点）"><a href="#HTTP-1-1-和-HTTP-2-0-有什么区别？（重点）" class="headerlink" title="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 有什么区别？（重点）"></a><strong>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 有什么区别？（重点）</strong></h4><p><img src="/img/jiwang/http1.1-vs-http2.0.png" alt="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 对比"></p><ul><li><strong>多路复用</strong>：HTTP&#x2F;2 单连接并发请求；HTTP&#x2F;1.1 连接内串行</li><li><strong>二进制分帧</strong>：HTTP&#x2F;2 二进制传输；HTTP&#x2F;1.1 文本报文</li><li><strong>队头阻塞</strong>：HTTP&#x2F;2 解决应用层阻塞；HTTP&#x2F;1.1 存在</li><li><strong>头部压缩</strong>：HTTP&#x2F;2 支持 HPACK；HTTP&#x2F;1.1 不支持</li><li><strong>服务器推送</strong>：HTTP&#x2F;2 支持；HTTP&#x2F;1.1 不支持</li></ul><h4 id="HTTP-2-0-和-HTTP-3-0-有什么区别？"><a href="#HTTP-2-0-和-HTTP-3-0-有什么区别？" class="headerlink" title="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？"></a><strong>HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？</strong></h4><p><img src="/img/jiwang/http2.0-vs-http3.0.png" alt="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 对比"></p><ul><li><strong>传输协议</strong>：HTTP&#x2F;2 基于 <strong>TCP</strong>；HTTP&#x2F;3 基于 <strong>QUIC（UDP）</strong></li><li><strong>连接建立</strong>：HTTP&#x2F;2 需 TCP + TLS 握手；HTTP&#x2F;3 支持 <strong>0-RTT &#x2F; 1-RTT</strong></li><li><strong>队头阻塞</strong>：HTTP&#x2F;2 存在 <strong>TCP 层 HOL</strong>；HTTP&#x2F;3 <strong>基本解决</strong></li><li><strong>头部压缩</strong>：HTTP&#x2F;2 使用 <strong>HPACK</strong>；HTTP&#x2F;3 使用 <strong>QPACK</strong></li><li><strong>连接迁移</strong>：HTTP&#x2F;3 支持（基于 Connection ID）；HTTP&#x2F;2 不支持</li><li><strong>安全性</strong>：HTTP&#x2F;2 TLS 运行在 TCP 之上；HTTP&#x2F;3 <strong>QUIC 内建加密</strong>整个数据包</li></ul><h4 id="三种HTTP协议比较"><a href="#三种HTTP协议比较" class="headerlink" title="三种HTTP协议比较"></a><strong>三种HTTP协议比较</strong></h4><p><img src="/img/jiwang/http-3-implementation.png" alt="http-3-implementation"></p><h4 id="HTTP-1-1-和-HTTP-2-0-的队头阻塞有什么不同？"><a href="#HTTP-1-1-和-HTTP-2-0-的队头阻塞有什么不同？" class="headerlink" title="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的队头阻塞有什么不同？"></a><strong>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的队头阻塞有什么不同？</strong></h4><table><thead><tr><th>方面</th><th>HTTP&#x2F;1.1 的队头阻塞</th><th>HTTP&#x2F;2.0 的队头阻塞</th></tr></thead><tbody><tr><td>阻塞层级</td><td>应用层（HTTP 协议本身限制）</td><td>传输层（TCP 协议限制）</td></tr><tr><td>根本原因</td><td>无法多路复用，请求和响应必须按顺序传输</td><td>TCP 要求数据包按序交付，丢包会阻塞整个连接</td></tr><tr><td>受影响范围</td><td>单个 HTTP 请求&#x2F;响应会阻塞后续请求&#x2F;响应</td><td>单个 TCP 包丢失会影响所有 HTTP&#x2F;2.0 流</td></tr><tr><td>缓解方法</td><td>开启多个并行 TCP 连接（一般限制6个）</td><td>减少丢包，或使用基于 UDP 的 QUIC</td></tr><tr><td>影响场景</td><td>几乎每次都会发生，尤其是大文件阻塞小文件</td><td>丢包率较高的网络环境下更明显</td></tr></tbody></table><h4 id="HTTP-是不保存状态的协议-如何保存用户状态-（重点）"><a href="#HTTP-是不保存状态的协议-如何保存用户状态-（重点）" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?（重点）"></a><strong>HTTP 是不保存状态的协议, 如何保存用户状态?（重点）</strong></h4><p>HTTP 协议本身是 <strong>无状态的 (stateless)</strong> 。<br>为了解决这个问题，主要有以下几种常用机制：</p><p><strong>方案一：Cookie + Session（主流）</strong></p><ul><li>服务端创建 <strong>Session</strong> 保存用户状态</li><li>通过 <strong>Cookie 存 SessionID</strong></li><li>每次请求自动携带 SessionID</li><li>Session 常存于 <strong>Redis &#x2F; 内存</strong></li></ul><blockquote><p>特点：有状态、依赖 Cookie、实现简单、广泛使用</p></blockquote><p><strong>方案二：URL 重写（不常用）</strong></p><ul><li>将 SessionID 放入 URL 参数中</li><li>服务器从 URL 中识别用户</li></ul><blockquote><p>缺点：不安全、不美观、对搜索引擎优化(SEO)不友好</p></blockquote><p><strong>方案三：Token（如 JWT）</strong></p><ul><li>登录成功后返回 <strong>Token</strong></li><li>客户端自行保存（Header &#x2F; localStorage）</li><li>每次请求携带 Token</li><li>服务端 <strong>不保存会话状态</strong></li></ul><blockquote><p>特点：无状态、适合前后端分离和微服务</p></blockquote><table><thead><tr><th>对比点</th><th>Session</th><th>JWT &#x2F; Token</th></tr></thead><tbody><tr><td>状态存储</td><td>服务端保存会话状态</td><td>客户端保存，服务端无状态</td></tr><tr><td>依赖 Cookie</td><td>是</td><td>否（通常放 Header）</td></tr><tr><td>扩展性</td><td>分布式需共享 Session</td><td>天然适合分布式</td></tr><tr><td>安全控制</td><td>可随时失效 &#x2F; 踢下线</td><td>一旦签发难以主动失效</td></tr><tr><td>性能开销</td><td>需查询 Session 存储</td><td>无需查库，直接校验</td></tr><tr><td>适用架构</td><td>传统 Web &#x2F; 单体应用</td><td>前后端分离 &#x2F; 微服务</td></tr><tr><td>Token 体积</td><td>小（仅 SessionID）</td><td>较大（携带用户信息）</td></tr><tr><td>常见存储</td><td>内存 &#x2F; Redis</td><td>Header &#x2F; localStorage</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软高级软件设计期末复习</title>
    <link href="/2026/02/10/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/10/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>高级软件设计简答题汇总</p><p><strong>设计模式和类库有什么不同</strong></p><ul><li><p>定义与目的</p><blockquote><p>解决问题，重复使用的框架，经过验证的最佳实践，解决设计问题</p><p>封装特定功能的类和接口的集合，提供具体实现</p></blockquote></li><li><p>抽象级别</p><blockquote><p>更高级别抽象，方法论，组织代码和模块</p><p>具体实现，提供可直接使用的代码</p></blockquote></li><li><p>通用性和使用范围</p><blockquote><p>通用性更高，适合多种语言和项目，举例</p><p>类库与特定编程语言绑定，Java Spring框架</p></blockquote></li><li><p>重用程度</p><blockquote><p>重用思想和方法，而非代码</p><p>重用代码</p></blockquote></li></ul><p><strong>工厂设计模式的三个OO原则</strong></p><ul><li><p>单一职责原则</p><blockquote><p>一个类应当只有一个引起变化的原因。创建对象的职责被分配给专门的工厂，可以将创建与使用分离。</p><p>工厂只关心对象的创建，而不关心对象的具体使用。</p></blockquote></li><li><p>依赖倒置原则</p><blockquote><p>高层模块不应当依赖于底层模块，都应该依赖于抽象。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>客户端代码依赖于抽象的工厂，而不依赖于具体的工厂实现类。</p></blockquote></li><li><p>开闭原则</p><blockquote><p>软件实体应当对扩展开放，对修改封闭。工厂方法模式允许系统不修改代码，引入新类型的对象，可以添加新的工厂扩展系统。</p></blockquote></li></ul><p><strong>什么是设计模式，什么是design pattern catalog？</strong></p><ul><li><p>在软件工程中，针对特定问题的典型解决方案的一种标准化描述。最佳实践，解决问题，不是代码，而是指导方案</p><blockquote><p>包含模式名称、问题、解决方案、效果</p><p>分三大类：创建型、结构型、行为型</p></blockquote></li><li><p>Design pattern catalog 是指收集多种设计模式的目录。包含详细描述、示例、优缺点。</p></li></ul><p><strong>为什么“依赖倒置原则”被认为是大多数设计模式的核心？</strong></p><ul><li>先介绍依赖倒置原则，高层不应依赖低层，应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li><li>降低模块之间的耦合。</li></ul><p><strong>比较策略模式和状态模式</strong></p><ul><li><p>都是行为型设计模式，然后从目的、应用场景、实现、优缺点来讲</p><blockquote><p><strong>目的</strong>：策略模式允许运行时选择算法或行为，状态模式允许对象改变内部状态来改变行为</p><p><strong>应用场景</strong>：</p><p>策略模式</p><ul><li>用于多种类似算法或行为的互换使用（不同排序算法），运行时可切换</li><li>避免条件语句，去除条件语句决定执行哪个算法</li><li>封装算法的变化</li></ul><p>状态模式</p><ul><li>对象行为依赖于其状态，行为随着状态改变而改变</li><li>对象有复杂的状态逻辑，状态转换明确</li><li>避免对象行为的膨胀</li></ul><p><strong>实现</strong>：</p><ul><li>策略模式定义策略接口，创建具体策略类，上下文使用策略接口作为字段，调用具体策略实现</li><li>状态模式将每种状态封装成独立的类，将状态转换的逻辑放在状态类内部实现</li></ul><p><strong>优缺点</strong>：</p><ul><li>策略模式提高复用性，独立于客户端变化，但需了解策略之间差异，增加了复杂性</li><li>状态模式将逻辑分散到状态类中，易于扩展状态，但引入很多状态类，增加系统复杂性</li></ul></blockquote></li></ul><p><strong>比较适配器、外观和装饰器设计模式的意图和模式</strong></p><ul><li>适配器模式将一个类的接口转换成期望的另一个类的接口，让不兼容的类一起工作（整合第三方库）</li><li>外观模式提供统一的接口，访问子系统的一群接口，使子系统更易使用（简化客户端与复杂系统的交互）</li><li>装饰器模式动态地给对象添加额外的职责而不改变对象接口，比生成子类灵活（动态添加功能）</li></ul><p><strong>比较适配器模式、装饰器模式和代理模式的目的与结构差异。</strong></p><ul><li><p>都是结构型设计模式，然后写目的和结构</p><blockquote><p>适配器模式的目的是解决接口不兼容问题，通过包装已有对象将其接口转换为客户端期望的接口</p><p>装饰器模式的目的是在不修改原对象的情况下动态地为对象增加功能，其结构呈现<strong>链式包装</strong></p><p>代理模式的目的是控制对对象的访问，在客户端与真实对象之间提供一个代理层。</p><p>三者在结构上都通过<strong>组合方式</strong>包装对象，</p></blockquote></li></ul><p><strong>比较透明组合和安全组合。</strong></p><ul><li><p>讲定义和优缺点</p><blockquote><p><strong>定义</strong>：透明组合的Component中包含管理子部件的操作，对于Leaf节点和Composite节点都可见。而安全组合管理子部件的操作不再Component接口中定义，而是只在Composite节点类中实现。</p><p><strong>优缺点</strong>：</p><p>透明组合客户端通义对待叶节点和容器节点，不必关心操作的是哪个。但牺牲了单一职责原则，叶节点包含多余的操作可能引起运行时错误。</p><p>安全组合叶节点不提供无关的操作，遵循单一职责原则，更加安全。但牺牲了透明性，处理节点要进行类型判断，增加了代码的复杂性。</p></blockquote></li></ul><p><strong>比较工厂方法模式与抽象工厂模式的适用场景。</strong></p><ul><li>工厂方法模式适用于系统只涉及一种产品类型，子类决定创建哪种产品，产品之间没有强关联（不同类型的解析器）</li><li>抽象工厂模式适用于创建一组相关或相互依赖产品族的产品族的场景，强调产品一致性（不同风格的UI组件）</li></ul><p><strong>比较组合模式与装饰模式在结构上的异同。</strong></p><ul><li>相同点：都使用抽象组件（Component），都通过递归方式组合对象，而不是继承。</li><li>不同点：Composite中包含多个Component，而Decorator中只包装一个Component。组合模式关注层次结构，形成树结构，而装饰模式关注功能扩展，形成链式结构。</li></ul><p><strong>说明装饰者模式如何体现开闭原则和合成复用原则。</strong></p><ul><li>先扯两个概念。</li><li>开闭原则：装饰者模式通过引入装饰类在不修改原有类的情况下动态扩展对象功能，完美体现了开闭原则。</li><li>合成复用原则：通过对象组合实现功能扩展，避免了继承带来的类爆炸问题，符合合成复用原则。</li></ul><p><strong>说明观察者模式如何体现依赖倒置原则与迪米特法则。</strong></p><ul><li>先扯概念</li><li>主题和观察者通过抽象接口解耦，高层模块 Subject 不再依赖具体实现，体现依赖倒置原则。</li><li>主题对象只与观察者接口通信，不与观察者的具体实现发生依赖，符合迪米特法则。</li></ul><p><strong>说明模板方法模式如何体现开闭原则。</strong></p><ul><li>开闭原则定义</li><li>模板方法模式通过固定算法骨架、延迟步骤实现，使系统在不修改算法结构的前提下即可扩展新行为，从而体现了开闭原则。</li></ul><p><strong>说明组合模式如何体现里氏替换原则。</strong></p><ul><li>组合模式通过为叶子对象和组合对象定义统一的抽象组件接口，使客户端对单个对象和组合对象的使用具有一致性，从而保证了任何组件子类对象都可以替换抽象组件出现的位置而不影响程序行为，体现了里氏替换原则。</li></ul><p><strong>观察者模式中的update方法是否必须？请说明理由。</strong></p><ul><li>观察者模式中的update方法通常是必须的</li><li>先讲角色：观察者（Observer）和被观察者（Subject）。被观察者维护一个观察者列表，并在状态变化时通知它们。观察者需要有一个方法来接收并响应这些通知，这就是 update 方法的作用。通过 update 方法，观察者可以得知被观察者的状态变化并作出相应的反应。</li><li>再讲通知方式：当被观察者的状态改变时，它会调用每个注册观察者的 update 方法，以此来通知观察者其状态已改变。</li><li>灵活性与一致性：在某些实现中，update 方法可以接收参数以提供关于状态变化的更多信息。</li><li>update概念上必需，但具体形式并非固定，可以通过回调、事件机制等方式实现通知。</li></ul><p><strong>在什么情况下应当使用策略模式？举例说明。</strong></p><ul><li>用于多种类似算法或行为的互换使用（不同排序算法），运行时可切换</li><li>避免条件语句，去除条件语句决定执行哪个算法</li><li>封装算法的变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>高级软件设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软统计模型期末复习</title>
    <link href="/2026/02/06/2024%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/06/2024%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文为2024统计模型期末试卷回忆版，既作为课程复习笔记，也希望通过系统梳理，加深对算法思想与应用场景的认识。</p><ul><li>其中，简答题8道＋计算题5道</li><li>2024版简答题新增了部分我认为会考的内容作为复习，所以有12道，实际只有8道</li><li>2025统计模型计算题新增了 <code>Γ函数</code> 作为考点，其他的题目大同小异。</li><li>回忆版仅供参考。</li></ul><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li><strong>简述 EM 算法的基本思想、主要步骤，并说明其优缺点与应用场景。</strong></li><li><strong>何为聚类？简述 K-means 聚类算法的基本流程及其优缺点。</strong></li><li><strong>什么是层次聚类？写出两种常用的簇间距离计算方法及其变种。</strong></li><li><strong>简述分类问题中的：二分类、多分类、多标签分类与排序问题的区别及应用场景。</strong></li><li><strong>简述训练集、验证集、测试集在分类问题中的作用与区别。</strong></li><li><strong>简述决策树分类算法，并说明 C4.5 相比 ID3 的主要改进。</strong></li><li><strong>给出泊松分布的概率密度函数，描述参数k和的含义。</strong></li><li><strong>给出正态分布的概率密度函数，以及均值和方差。</strong></li><li><strong>写出四种常见概率分布（二项分布、Poisson、指数、正态），并说明各自应用场景。</strong></li><li><strong>什么是 N-Gram 模型？解释 Unigram、Bigram、Trigram，并说明其在语言建模中的作用。</strong></li><li><strong>给出NLP的典型任务，以及其特征应用。</strong></li><li><strong>什么是词项-文档矩阵，如何构造？</strong></li></ul><h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><ul><li><h3 id="K-means-聚类算法计算"><a href="#K-means-聚类算法计算" class="headerlink" title="K-means 聚类算法计算"></a><strong>K-means 聚类算法计算</strong></h3><blockquote><p>给定如下样本点：<br>A(1,1)，B(2,1)，C(5,4)，D(6,5)<br>初始聚类中心为 μ₁(1,1)，μ₂(5,4)。</p></blockquote><p>请完成 <strong>第一次 K-means 迭代</strong>：<br> ① 样本分配<br> ② 计算新的聚类中心</p><p><img src="/img/stat-model/image-20260101212137596.png" alt="image-20260101212137596"></p></li><li><h3 id="正态分布极大似然估计"><a href="#正态分布极大似然估计" class="headerlink" title="正态分布极大似然估计"></a><strong>正态分布极大似然估计</strong></h3><blockquote><p>给定样本 x1,x2,…,xn来自正态分布 N(μ,σ2)</p></blockquote><p>① 写出似然函数hexo clean<br>② 写出对数似然函数<br>③ 对参数求偏导，给出 μ 和 σ2 的极大似然估计值</p><p><img src="/img/stat-model/image-20260101212150711.png" alt="image-20260101212150711"></p></li><li><h3 id="朴素贝叶斯分类计算"><a href="#朴素贝叶斯分类计算" class="headerlink" title="朴素贝叶斯分类计算"></a><strong>朴素贝叶斯分类计算</strong></h3><blockquote><p>已知某分类问题中先验概率和条件概率如下：</p><p>P(C1)&#x3D;0.6,  P(C2)&#x3D;0.4<br>P(x∣C1)&#x3D;0.2,  P(x∣C2)&#x3D;0.5</p></blockquote><p>使用<strong>全概率公式</strong>计算后验概率 P(C1∣x) 与 P(C2∣x) ，并给出分类结果。</p><p><img src="/img/stat-model/image-20260101212204905.png" alt="image-20260101212204905"></p></li><li><h3 id="Bigram-语言模型计算"><a href="#Bigram-语言模型计算" class="headerlink" title="Bigram 语言模型计算"></a><strong>Bigram 语言模型计算</strong></h3><blockquote><p>语料为：<br><code>I love machine learning</code></p></blockquote><p>① 写出该句子的 Bigram 表示<br>② 计算句子概率</p><p><img src="/img/stat-model/image-20260101212216578.png" alt="image-20260101212216578"></p></li><li><h3 id="词袋模型计算"><a href="#词袋模型计算" class="headerlink" title="词袋模型计算"></a><strong>词袋模型计算</strong></h3><blockquote><p>给定语料库：<br>文档1：<code>I love NLP</code><br>文档2：<code>I love machine learning</code></p></blockquote><p>① 构建词汇表<br>② 构造对应的词项–文档矩阵</p><p><img src="/img/stat-model/image-20260101212254957.png" alt="image-20260101212254957"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计模型</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软软件安全期末复习</title>
    <link href="/2026/02/06/%E5%8D%97%E8%BD%AF%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/06/%E5%8D%97%E8%BD%AF%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文是对《软件安全》课程期末内容的系统性复习与梳理，围绕软件漏洞、恶意代码、安全开发生命周期（SDL）、安全需求与设计、软件版权与法律等核心知识点，对教材中的重点概念、常见考点和易混淆内容进行了整理与归纳。</p><p>​2025冷门考点：威胁建模、 Windows安全漏洞保护的基本技术及其存在的问题</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><p><strong>什么是零日(0day)漏洞?什么是零日(0day)攻击?</strong>（2024）</p><blockquote><p>未公开披露的软件漏洞，没有给软件厂商时间去打补丁或给出解决方案。</p><p>攻击者利用零日漏洞开发攻击工具攻击</p></blockquote></li><li><p>为什么说面对当前的全球网络空间安全威胁，必须对软件安全给予强烈关注?</p><blockquote><p>背景：软件无处不在</p><p>问题：漏洞普遍存在</p><p>结论：重视软件安全</p></blockquote></li><li><p>当前，黑客为了能够有效达到窃取数据、破坏系统的目的，常常通过挖掘或是购买零日漏洞，开发针对零日漏洞的攻击工具，零日漏洞威胁实际上反映了软件系统存在的一个什么问题?</p><blockquote><p>先介绍零日漏洞</p><p>系统的脆弱性，漏洞的隐秘性，修复的滞后性</p></blockquote></li><li><p>根据本书的介绍，软件安全威胁可以分为哪几类?</p><blockquote><p>软件漏洞、恶意代码、软件侵权</p></blockquote></li><li><p>试谈谈对软件漏洞的认识，举出软件漏洞造成危害的事件例子。</p><blockquote><p>软件生命周期与安全相关的设计错误、编码缺陷和运行故障</p><p>举例两方面：</p><p>软件漏洞在运行期间造成错误、崩溃、死机：操作系统蓝屏、内存泄漏崩溃</p><p>软件漏洞被黑客利用攻击：数据库获取明文口令、缓冲区溢出攻击获得远程权限</p></blockquote></li><li><p>什么是恶意代码?除了传统的计算机病毒,还有哪些恶意代码类型?</p><blockquote><p>未授权，搞破坏</p><p>蠕虫、特洛伊木马、后门、勒索软件…</p></blockquote></li><li><p>针对软件的版权，有哪些侵权行为?</p><blockquote><p>未经许可，发表，登记，修改，翻译</p><p>复制、部分复制</p><p>合作软件独立发表</p><p>向公众发行、出租、传播</p><p>转让他人著作权</p></blockquote></li><li><p>谈谈对软件安全概念的理解。</p><blockquote><p>提供系统方法标识、追踪危害性软件，缓解和控制</p><p>三大属性CIA：保密性、完整性、可用性</p><p>其他属性：可认证，审计..</p></blockquote></li><li><p>简述软件和软件工程的概念。</p><blockquote><p>计算机程序、数据和相关文档</p><p>工程方法开发维护软件，结合好技术，高效开发，是技术和管理结合的工程学科</p></blockquote></li><li><p>对照一般软件工程的概念，软件安全工程主要增添了哪些任务</p><blockquote><p>安全代码、安全环境、安全测试、网络安全、安全维护、安全标准、安全审计</p></blockquote></li><li><p>谈谈软件安全与软件危机、软件质量和软件质量保证、软件保障、软件可靠性、应用软件系统安全、可信软件和软件定义安全等概念的区别和联系。</p><blockquote><p>给了</p></blockquote></li><li><p>确保软件安全的基本思路是什么?软件安全涉及的技术主要有哪些方面?</p><blockquote><p>挖掘安全漏洞，分析给出修复</p><p>事先分析可能发生的原因，开发中规避</p><p>软件安全属性认知、信息系统安全工程、软件安全开发（背不出来也给了）</p></blockquote></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ul><li><p><strong>试述软件漏洞的概念，谈谈软件漏洞与软件错误、软件缺陷、软件 Bug 的区别与联系。</strong>（2024）</p><blockquote><p>讲讲软件漏洞定义（同上）</p><p>错误存在软件开发生命周期中（需求、设计、编码错误一堆错误），缺陷&#x2F;bug存在软件产品中（静态）</p></blockquote></li><li><p>为什么说安全缺陷或者说Bug是一个需要考虑具体环境、具体对象的概念?</p><blockquote><p>举例Https</p><p>讲讲安全性需求是否需要加入考量，然后说具体问题具体分析</p></blockquote></li><li><p>试分析软件漏洞的成因。</p><blockquote><p>看到成因，刨根问底</p><p>系统结构、软件大型化复杂化、使用场景、缺乏重视</p></blockquote></li><li><p>软件漏洞如何分类分级管理?</p><blockquote><p>成因类：</p><p>利用位置类：</p><p>威胁类型类：</p><p>严重级</p><p>漏洞评分系统级</p></blockquote></li><li><p>软件漏洞买卖合法吗?软件漏洞应当如何管控?</p><blockquote><p>不合法</p><p>认清并加以重视（漏洞）</p><p>限制并获得双赢（”白帽”）</p><p>加强法律建设</p></blockquote></li><li><p>厂商发布漏洞信息的标准过程是怎样的?</p><blockquote><p>识别、评估、选择补救措施、发布</p></blockquote></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ul><li><p>程序运行时的内存布局是怎样的?</p><blockquote><p>栈堆代数，中心扩散，上低下高</p></blockquote></li><li><p>在程序运行时，用来动态申请分配数据和对象的内存区域形式称为什么?</p><blockquote><p>堆</p></blockquote></li><li><p><strong>什么是缓冲区溢出漏洞?</strong></p><blockquote><p>向缓冲区写数据时未作边界检查，导致超过预先分配的边界，覆盖合法数据</p><p>黑客利用缓冲区溢出攻击，获取系统权限</p></blockquote></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul><li><p>什么是软件的生命周期?软件生命周期通常包括哪几个阶段?</p><blockquote><p>定义、开发、维护</p><p>定义：问题定义、可行性分析、需求分析</p><p>开发：设计、编码、测试</p><p>维护</p></blockquote></li><li><p>什么是软件过程？什么是软件开发（过程）模型？为什么从20世纪90年代以后，人们更多使用“软件过程”来替代传统的“软件开发模型”？（难背）</p><blockquote><p>获得高质量软件完成任务的框架，规定工作步骤</p><p>软件生命周期开发、运行、维护的全部工作任务的框架</p><p>更高效、更灵活、更高精度、减少质量问题、团队</p></blockquote></li><li><p>有哪些典型的软件开发模型？这些软件开发模型有什么区别与联系？</p><blockquote><p>螺旋、原型、瀑布、敏捷、增量、喷泉</p><p>迭代次数和时机、开发时间</p><p>影响开发过程与时机</p></blockquote></li><li><p><strong>SD3+C原则是SDL模型实施的基本原则，试简述其内容。</strong></p><blockquote><p>安全设计、安全配置、安全部署、沟通</p></blockquote></li><li><p>微软的SDL模型与传统的瀑布模型的关系是怎样的?</p><blockquote><p>发展而来，增加两个活动（安全和业务）</p></blockquote></li><li><p><strong>什么是敏捷SDL？敏捷SDL和经典SDL的主要区别是什么？</strong>（2024、2025）</p><blockquote><p>无阶段的迭代开发模型</p><p>并不是每个发布版本都要达到所有要求</p></blockquote></li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ul><li><p>为什么要进行需求分析?通常对软件系统有哪些需求?</p><blockquote><p>了解用户需求，需求分析是前提</p><p>功能、性能、质量属性、接口、约束</p></blockquote></li><li><p>为什么要进行安全需求分析?通常对软件系统有哪些安全需求?</p><blockquote><p>如何提高安全质量，减少安全漏洞</p><p>外部：法规、合规性、对策总结</p><p>内部：组织内部标准、指南，功能相关的安全需求</p></blockquote></li><li><p>软件安全需求分析的主要工作是什么?它和软件需求分析有什么区别与联系?</p><blockquote><p>在需求分析阶段，确定环境，了解安全需求内容，通过安全需求获取过程，分析安全需求</p><p>安全需求是客观的、安全需求从系统角度分析、按需采纳</p><p>是衍生、以功能性需求分析为基础、帮助从安全角度确定系统需求</p></blockquote></li><li><p>为什么说软件安全需求更多地来源于遵从性需求?</p><blockquote><p>用户难以提出，来自内外部安全政策和标准的遵从</p></blockquote></li><li><p>软件安全需求的获取方法有哪些?</p><blockquote><p>头脑风暴、问卷与访谈、策略分解、数据分类、主客体关系矩阵</p></blockquote></li><li><p><strong>软件安全需求的获取方法中的策略分解是指什么?</strong>（2024）</p><blockquote><p>将需遵守的内外部政策，分解成详细的安全需求</p></blockquote></li><li><p>软件安全需求的获取方法中的数据分类是指什么?</p><blockquote><p>按数据生命周期对数据分阶段划分、按数据重要性对保护级别划分</p></blockquote></li><li><p>软件安全需求的获取方法中的主&#x2F;客体关系矩阵是指什么?</p><blockquote><p>刻画基于使用用例的主客体操作关系，角色（列）与组件（行）的二维表示，与矩阵所允许的对应动作相违背的判定为威胁</p></blockquote></li><li><p>针对信息系统中的数据生命周期，通常应当考虑的安全需求有哪些?</p><blockquote><p>创建、处理、传输、存储、介质、归档</p><p>数据创建、访问和权限</p><p>数据泄漏保护</p><p>传输数据安全协议</p><p>数据存储格式，环境威胁</p><p>介质可靠性</p><p>归档数据处理政策</p></blockquote></li></ul><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ul><li><p>软件设计阶段的主要工作是什么?</p><blockquote><p>架构、界面接口、模块构件、数据模型、算法、部署</p></blockquote></li><li><p>软件安全设计阶段的主要工作是什么?</p><blockquote><p>软件架构安全性设计、软件架构安全性分析、软件安全功能设计</p></blockquote></li><li><p>为什么要进行软件架构设计?软件架构设计的主要工作是什么?软件架构安全性设计的主要工作是什么?</p><blockquote><p>开发高质量软件</p><p>理清需求、设计业务逻辑和接口……扯第一问、迭代架构设计</p><p>进行系统描述，确定安全级别、设计安全功能、解决易用性等问题</p></blockquote></li><li><p>为什么要进行软件架构安全性分析?软件架构安全性分析的基本过程是什么?</p><blockquote><p>编码前，要素验证，提供处理漏洞的机会</p><p>架构建模 –&gt; 检查安全需求  –&gt; 修改架构设计</p></blockquote></li><li><p>软件受攻击面是指什么?举例说明软件设计时可以采取哪些策略来降低受攻击面。</p><blockquote><p>用户或攻击者能访问到的所有功能和代码的总和（代码、接口、服务、协议）</p><p>重要性低功能取消、重要性中非默认开启、重要性高增加安全措施、重用安全的现有库。</p><p>IOS不支持java、flash</p></blockquote></li><li><p><strong>什么是最小授权原则?试举例说明软件设计时哪些措施是采用了最小授权原则。</strong>（2024）</p><blockquote><p>系统授予实体完成任务的最小权限，持续时间尽可能短。使不需要的特权使用可能性降到最低，保证安全</p><p>权限细粒度划分，高内聚低耦合模块化编程。</p></blockquote></li><li><p>什么是权限分离原则?试举例说明软件设计时哪些措施是采用了权限分离原则。</p><blockquote><p>将软件功能设计为需要两个或更多条件下才能实现。防止出问题时，整个软件面临风险</p><p>清晰划分模块，分散风险。可快速定位问题、单模块测试、重用和替换模块</p><p>不允许程序员检查自己编写的代码</p></blockquote></li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ul><li><p>软件安全编码阶段的主要工作有哪些?</p><blockquote><p>选择安全编程语言、版本管理、代码检测、安全编译</p></blockquote></li><li><p>什么是类型安全语言?哪些程序开发语言是类型安全的?</p><blockquote><p>提供类型安全保障机制的语言，操作仅作用于适当类型。C#、java</p></blockquote></li><li><p><strong>安全编译是指在代码编译阶段采取的哪些安全措施?</strong>（2024）</p><blockquote><p>集成编译环境、安全环境、真实模拟应用环境、多样化编译技术</p></blockquote></li><li><p>试列举几条安全编码原则,并举例说明这些原则的重要意义。</p><blockquote><p>验证输入、留意编译器警告、安全策略的架构与设计、保持简单性</p></blockquote></li></ul><h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><ul><li><p>试解释以下与恶意代码程序相关的计算机系统概念，以及各概念之间的联系与区别:进程、线程、动态链接库、 服务、注册表。</p><blockquote><p>进程是OS对正在运行的程序的抽象，动态，有生命周期，反应程序在数据集上的全部动态过程</p><p>线程是OS分配处理器资源的基本单位，讲讲进程与线程的关系</p><p>动态链接DLL是共享函数库的可执行文件，通过其他运行程序加载到内存中，可被多个进程加载</p><p>服务是OS在后台完成系统任务的程序，有各种权限</p><p>注册表是OS中使用的中央分层数据库，存储用户、程序、硬件配置必须的信息</p></blockquote></li><li><p>从危害、传播、激活和隐藏4个主要方面分析计算机病毒、蠕虫、木马、后门、Rootkit及勒索软件这几类恶 意代码类型的工作原理。</p><table><thead><tr><th align="center"></th><th align="center">病毒</th><th align="center">蠕虫</th><th align="center">木马</th><th align="center">后门</th><th align="center">Rootkit</th><th align="center">勒索软件</th></tr></thead><tbody><tr><td align="center"><strong>危害</strong></td><td align="center">破坏机密性、完整性、可用性</td><td align="center">网络拥塞、系统性能、安全隐患、反复性、破坏性</td><td align="center">非法进入系统、控制系统、破坏系统</td><td align="center">访问控制系统的通道，无直接攻击行为</td><td align="center">获得访问权限，隐藏在计算机中</td><td align="center">劫持用户资源、勒索钱财</td></tr><tr><td align="center"><strong>传播</strong></td><td align="center">存储设备、网络</td><td align="center">自我复制、网络</td><td align="center">自我传播、诱骗</td><td align="center"></td><td align="center"></td><td align="center">邮件、漏洞、网络、存储设备</td></tr><tr><td align="center"><strong>激活</strong></td><td align="center">特定条件</td><td align="center">自动化、系统漏洞</td><td align="center">用户操作</td><td align="center">开发者&#x2F;攻击者设置</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>隐藏</strong></td><td align="center">寄生程序或文档</td><td align="center">实体隐藏模块</td><td align="center">难以确定</td><td align="center"></td><td align="center">修改OS软件</td><td align="center"></td></tr></tbody></table></li><li><p>病毒程序与蠕虫程序的主要区别有哪些?</p><blockquote><p>病毒人为干预、蠕虫不需要；病毒感染文件系统，蠕虫影响系统与网络性能</p></blockquote></li><li><p><strong>什么是Rootkit?它与木马和后门有什么区别与联系?</strong>（2024）</p><blockquote><p>一类木马后门工具，修改操作系统软件，使攻击者获得权限并隐藏在计算机中</p><p>属于木马范畴，替换操作系统软件，伪装与隐藏机制</p><p>作为后门行使职责，口令、远程shell绕过检查机制。</p><p>Rootkit强调隐藏伪造欺骗，木马强调窃取与侵入。</p></blockquote></li><li><p>什么是勒索软件?为什么勒索软件成为近年来数量增长最快的恶意代码类型?（2025）</p><blockquote><p>劫持资产，勒索钱财的恶意软件</p><p>加密有效解密成本高、电子货币支付，变现快，追踪难、勒索软件即服务的出现，降低攻击门槛</p></blockquote></li><li><p>恶意代码防范的基本措施包括哪些?</p><blockquote><p>增强法律意识、健全管理制度、软件可信验证</p></blockquote></li></ul><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><ul><li><p>试从软件的权益处置角度，谈谈对商业软件、免费软件、共享软件（或试用软件）、闭源软件、自由软件及开源软件概念的理解。</p><blockquote><p>商业软件通过销售许可证或订阅方式获利，核心目的是盈利</p><p>免费软件是无需支付可使用的软件，源代码可能不公开，提供基础功能，高级功能可能需付费</p><p>共享软件提供试用版或部分功能免费，源代码通常不公开，通过共享试用吸引用户购买</p><p>闭源软件源代码私有，用户只能使用，不能修改与分发</p><p>自由软件用户可以自由使用、分发、修改，重视自由和开放源代码，通常遵循GUN GPL协议</p><p>开源软件允许用户修改分发，但不一定要求使用自由，主要强调开放源代码</p></blockquote></li><li><p>自由软件赋予软件使用者哪些“自由”？</p><blockquote><p>4种自由：</p><p>自由运行、自由研究、自由发布、自由改进</p></blockquote></li><li><p>试简述开源软件与自由软件的联系与区别。（2025）</p><blockquote><p>开源软件由自由软件发展而来，都具理想主义色彩，追求更多人使用、学习、改进</p><p>概念不同：自由软件比开源软件更严格，开放源代码。遵循GPL和BSD许可证的开源软件才符合自由软件</p><p>价值观不同：自由软件将自由作为道德标准，开源软件更注重软件发展</p></blockquote></li><li><p><strong>所开发的软件中使用了带 GPL 许可证的开源软件，那么这个软件是不是就要开源？</strong>（2024）</p><blockquote><p>是的。GNU通用公共许可证，在一个软件中使用了GPL许可证的产品，则该软件也要使用GPL许可证。“传染性”</p></blockquote></li></ul><h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><ul><li><p>根据我国法律，软件著作权人有哪些权利?在日常学习和生活中，有哪些违反软件著作权的行为?</p><blockquote><p>信息网络传播权、修改权、发表权、署名权、复制权、出租权、翻译权、发行权等</p></blockquote></li><li><p><strong>试述软件版权的概念。针对软件的版权，有哪些侵权行为?有哪些保护措施?</strong>（2024）</p><blockquote><p>软件知识产权的一部分，指软件著作权</p><p>软件盗版、逆向工程、信息泄漏</p><p>硬件：发行介质保护、软件狗、可信平台模块TPM</p><p>软件：注册验证、水印、代码混淆、软件加壳</p></blockquote></li><li><p>软件版权保护的目标有哪些?它与软件保护的目标有什么联系与区别?</p><blockquote><p>防止软件盗版、逆向工程、信息泄漏</p><p>是子集，谈交集外区别；措施同样可用于软件保护</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/02/06/hello-world/"/>
    <url>/2026/02/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
