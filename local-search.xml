<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络八股</title>
    <link href="/2026/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/"/>
    <url>/2026/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<p>本文参考并整理自 JavaGuide，对计算机网络中常见的面试高频问题进行了内容精简与结构化梳理。在保证核心概念准确性的前提下，尽量压缩表述、突出关键点，并结合个人理解做了适当的记忆扩展，便于快速复习和长期理解。</p><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>物（比特传输）、链（帧编码、差错控制）、网（路由和寻址）、输（进程通信）、会、示（编码、加密）、用</p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p>接（链路和物理）、网、输、用（会话、表示、应用）</p><h3 id="网络分层的原因"><a href="#网络分层的原因" class="headerlink" title="网络分层的原因"></a>网络分层的原因</h3><ol><li>各层相互独立（无需关注其他层）</li><li>提高灵活性和可替换性（多答特性）</li><li>大问题化小（复杂问题拆解）</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><p>应用层：<strong>HTTP</strong>、SMTP（发邮件）、POP3&#x2F;IMAP（收邮件）、FTP（文件）、Telnet（登录）、SSH、RTP(实时传输，通常UDP)、<strong>DNS</strong>（域名解析，UDP）</p><p>传输层：<strong>TCP</strong>（面向连接、可靠）、<strong>UDP</strong>（无连接、最大可能交付）</p><p>网络层：<strong>IP</strong>、ARP（IP转MAC）、ICMP（控制报文）、NAT（网络地址转换）、OSPF（基于链路状态的内部网关协议）、RIP（基于距离向量的内部网关协议）、BGP（边界网关协议）</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="输入URL到页面展示（重点）"><a href="#输入URL到页面展示（重点）" class="headerlink" title="输入URL到页面展示（重点）"></a><strong>输入URL到页面展示（重点）</strong></h4><ol><li>输入指定网页的 URL。</li><li>DNS 协议，解析出 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h4><p><img src="/img/jiwang/http-status-code.png" alt="常见 HTTP 状态码"></p><h4 id="常见-HTTP-头字段包括："><a href="#常见-HTTP-头字段包括：" class="headerlink" title="常见 HTTP 头字段包括："></a><strong>常见 HTTP 头字段包括：</strong></h4><ul><li>Host、User-Agent、Accept、Authorization、Cookie</li></ul><h4 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 有什么区别？"></a><strong>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 有什么区别？</strong></h4><p><img src="/img/jiwang/http1.0-vs-http1.1.png" alt="HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 对比"></p><ul><li>前者<strong>短连接</strong>、后者<strong>长连接</strong></li><li>后者新增多种<strong>状态码</strong></li><li>引入更多<strong>缓存控制</strong>策略（提供更多缓存头字段如：Entity tag、If-Match）</li><li><strong>带宽</strong>，加入range头域，允许只请求资源的某个部分</li><li><strong>Host头</strong>，允许同一个IP托管多个域名，实现虚拟主机</li></ul><h4 id="HTTP-1-1-和-HTTP-2-0-有什么区别？（重点）"><a href="#HTTP-1-1-和-HTTP-2-0-有什么区别？（重点）" class="headerlink" title="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 有什么区别？（重点）"></a><strong>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 有什么区别？（重点）</strong></h4><p><img src="/img/jiwang/http1.1-vs-http2.0.png" alt="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 对比"></p><ul><li><strong>多路复用</strong>：HTTP&#x2F;2 单连接并发请求；HTTP&#x2F;1.1 连接内串行</li><li><strong>二进制分帧</strong>：HTTP&#x2F;2 二进制传输；HTTP&#x2F;1.1 文本报文</li><li><strong>队头阻塞</strong>：HTTP&#x2F;2 解决应用层阻塞；HTTP&#x2F;1.1 存在</li><li><strong>头部压缩</strong>：HTTP&#x2F;2 支持 HPACK；HTTP&#x2F;1.1 不支持</li><li><strong>服务器推送</strong>：HTTP&#x2F;2 支持；HTTP&#x2F;1.1 不支持</li></ul><h4 id="HTTP-2-0-和-HTTP-3-0-有什么区别？"><a href="#HTTP-2-0-和-HTTP-3-0-有什么区别？" class="headerlink" title="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？"></a><strong>HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？</strong></h4><p><img src="/img/jiwang/http2.0-vs-http3.0.png" alt="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 对比"></p><ul><li><strong>传输协议</strong>：HTTP&#x2F;2 基于 <strong>TCP</strong>；HTTP&#x2F;3 基于 <strong>QUIC（UDP）</strong></li><li><strong>连接建立</strong>：HTTP&#x2F;2 需 TCP + TLS 握手；HTTP&#x2F;3 支持 <strong>0-RTT &#x2F; 1-RTT</strong></li><li><strong>队头阻塞</strong>：HTTP&#x2F;2 存在 <strong>TCP 层 HOL</strong>；HTTP&#x2F;3 <strong>基本解决</strong></li><li><strong>头部压缩</strong>：HTTP&#x2F;2 使用 <strong>HPACK</strong>；HTTP&#x2F;3 使用 <strong>QPACK</strong></li><li><strong>连接迁移</strong>：HTTP&#x2F;3 支持（基于 Connection ID）；HTTP&#x2F;2 不支持</li><li><strong>安全性</strong>：HTTP&#x2F;2 TLS 运行在 TCP 之上；HTTP&#x2F;3 <strong>QUIC 内建加密</strong>整个数据包</li></ul><h4 id="三种HTTP协议比较"><a href="#三种HTTP协议比较" class="headerlink" title="三种HTTP协议比较"></a><strong>三种HTTP协议比较</strong></h4><p><img src="/img/jiwang/http-3-implementation.png" alt="http-3-implementation"></p><h4 id="HTTP-1-1-和-HTTP-2-0-的队头阻塞有什么不同？"><a href="#HTTP-1-1-和-HTTP-2-0-的队头阻塞有什么不同？" class="headerlink" title="HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的队头阻塞有什么不同？"></a><strong>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的队头阻塞有什么不同？</strong></h4><table><thead><tr><th>方面</th><th>HTTP&#x2F;1.1 的队头阻塞</th><th>HTTP&#x2F;2.0 的队头阻塞</th></tr></thead><tbody><tr><td>阻塞层级</td><td>应用层（HTTP 协议本身限制）</td><td>传输层（TCP 协议限制）</td></tr><tr><td>根本原因</td><td>无法多路复用，请求和响应必须按顺序传输</td><td>TCP 要求数据包按序交付，丢包会阻塞整个连接</td></tr><tr><td>受影响范围</td><td>单个 HTTP 请求&#x2F;响应会阻塞后续请求&#x2F;响应</td><td>单个 TCP 包丢失会影响所有 HTTP&#x2F;2.0 流</td></tr><tr><td>缓解方法</td><td>开启多个并行 TCP 连接（一般限制6个）</td><td>减少丢包，或使用基于 UDP 的 QUIC</td></tr><tr><td>影响场景</td><td>几乎每次都会发生，尤其是大文件阻塞小文件</td><td>丢包率较高的网络环境下更明显</td></tr></tbody></table><h4 id="HTTP-是不保存状态的协议-如何保存用户状态-（重点）"><a href="#HTTP-是不保存状态的协议-如何保存用户状态-（重点）" class="headerlink" title="HTTP 是不保存状态的协议, 如何保存用户状态?（重点）"></a><strong>HTTP 是不保存状态的协议, 如何保存用户状态?（重点）</strong></h4><p>HTTP 协议本身是 <strong>无状态的 (stateless)</strong> 。<br>为了解决这个问题，主要有以下几种常用机制：</p><p><strong>方案一：Cookie + Session（主流）</strong></p><ul><li>服务端创建 <strong>Session</strong> 保存用户状态</li><li>通过 <strong>Cookie 存 SessionID</strong></li><li>每次请求自动携带 SessionID</li><li>Session 常存于 <strong>Redis &#x2F; 内存</strong></li></ul><blockquote><p>特点：有状态、依赖 Cookie、实现简单、广泛使用</p></blockquote><p><strong>方案二：URL 重写（不常用）</strong></p><ul><li>将 SessionID 放入 URL 参数中</li><li>服务器从 URL 中识别用户</li></ul><blockquote><p>缺点：不安全、不美观、对搜索引擎优化(SEO)不友好</p></blockquote><p><strong>方案三：Token（如 JWT）</strong></p><ul><li>登录成功后返回 <strong>Token</strong></li><li>客户端自行保存（Header &#x2F; localStorage）</li><li>每次请求携带 Token</li><li>服务端 <strong>不保存会话状态</strong></li></ul><blockquote><p>特点：无状态、适合前后端分离和微服务</p></blockquote><table><thead><tr><th>对比点</th><th>Session</th><th>JWT &#x2F; Token</th></tr></thead><tbody><tr><td>状态存储</td><td>服务端保存会话状态</td><td>客户端保存，服务端无状态</td></tr><tr><td>依赖 Cookie</td><td>是</td><td>否（通常放 Header）</td></tr><tr><td>扩展性</td><td>分布式需共享 Session</td><td>天然适合分布式</td></tr><tr><td>安全控制</td><td>可随时失效 &#x2F; 踢下线</td><td>一旦签发难以主动失效</td></tr><tr><td>性能开销</td><td>需查询 Session 存储</td><td>无需查库，直接校验</td></tr><tr><td>适用架构</td><td>传统 Web &#x2F; 单体应用</td><td>前后端分离 &#x2F; 微服务</td></tr><tr><td>Token 体积</td><td>小（仅 SessionID）</td><td>较大（携带用户信息）</td></tr><tr><td>常见存储</td><td>内存 &#x2F; Redis</td><td>Header &#x2F; localStorage</td></tr></tbody></table><h4 id="URL和URI的区别"><a href="#URL和URI的区别" class="headerlink" title="URL和URI的区别"></a><strong>URL和URI的区别</strong></h4><ul><li>URI 是统一资源标识符，用来唯一标识资源；</li><li>URL 是 URI 的一种，不仅标识资源，还指明资源的位置和访问方式。</li><li>所以 URL 一定是 URI，但 URI 不一定是 URL。</li></ul><h4 id="Cookie-和-Session-有什么区别？"><a href="#Cookie-和-Session-有什么区别？" class="headerlink" title="Cookie 和 Session 有什么区别？"></a><strong>Cookie 和 Session 有什么区别？</strong></h4><table><thead><tr><th>对比点</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>浏览器（客户端）</td><td>服务器</td></tr><tr><td>数据存什么</td><td>可以直接存用户信息</td><td>通常存用户状态数据</td></tr><tr><td>安全性</td><td>低（可被篡改）</td><td>相对高（存在服务器）</td></tr><tr><td>大小限制</td><td>一般 4KB 左右</td><td>理论不限（受服务器内存限制）</td></tr><tr><td>是否占服务器资源</td><td>不占</td><td>占</td></tr><tr><td>依赖关系</td><td>可独立存在</td><td>依赖 Cookie（通常）</td></tr></tbody></table><h4 id="GET-和-POST-的区别（重点）"><a href="#GET-和-POST-的区别（重点）" class="headerlink" title="GET 和 POST 的区别（重点）"></a><strong>GET 和 POST 的区别（重点）</strong></h4><table><thead><tr><th>对比维度</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>语义（核心区别）</strong></td><td>获取 &#x2F; 查询资源</td><td>创建 &#x2F; 修改资源</td></tr><tr><td><strong>是否幂等</strong></td><td>是（多次执行结果相同）</td><td>否（可能产生不同结果）</td></tr><tr><td><strong>是否安全（语义层面）</strong></td><td>是（不改变资源状态）</td><td>否（会改变资源状态）</td></tr><tr><td><strong>参数位置</strong></td><td>URL 查询字符串（query string）</td><td>请求体（body）</td></tr><tr><td><strong>参数格式</strong></td><td>URL 编码</td><td><code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>application/json</code> 等</td></tr><tr><td><strong>长度限制</strong></td><td>受浏览器和服务器对 URL 长度限制</td><td>理论无限制（受服务器限制）</td></tr><tr><td><strong>是否可缓存</strong></td><td>可以（浏览器&#x2F;代理默认可缓存）</td><td>默认不可缓存</td></tr><tr><td><strong>数据暴露性</strong></td><td>参数显示在 URL 中，容易暴露</td><td>参数在 body 中，相对不易暴露</td></tr><tr><td><strong>是否一定更安全？</strong></td><td>否（HTTP 下都是明文）</td><td>否（HTTP 下都是明文）</td></tr><tr><td><strong>典型场景</strong></td><td>搜索、查询列表、获取详情</td><td>登录、注册、提交表单、创建订单</td></tr></tbody></table><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h3><h4 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a><strong>什么是WebSocket</strong></h4><ul><li>WebSocket 是一种基于 TCP 的全双工通信协议。</li><li>它通过 HTTP 握手建立连接，然后升级为 WebSocket 协议。</li><li>与 HTTP 的请求-响应模式不同，WebSocket 支持服务器主动向客户端推送数据，适用于实时通信场景，如聊天室、实时行情等。</li></ul><h4 id="WebSocket-和-HTTP-有什么区别？"><a href="#WebSocket-和-HTTP-有什么区别？" class="headerlink" title="WebSocket 和 HTTP 有什么区别？"></a><strong>WebSocket 和 HTTP 有什么区别？</strong></h4><table><thead><tr><th>对比维度</th><th>HTTP</th><th>WebSocket</th></tr></thead><tbody><tr><td>协议层级</td><td>应用层协议（基于 TCP）</td><td>应用层协议（基于 TCP）</td></tr><tr><td>通信模式</td><td>单向（请求-响应）</td><td>双向（全双工）</td></tr><tr><td>谁发起通信</td><td>只能客户端发起</td><td>双方都可以主动发送</td></tr><tr><td>是否支持实时通信</td><td>不适合</td><td>非常适合</td></tr><tr><td>协议前缀</td><td><code>http://</code> <code>https://</code></td><td><code>ws://</code> <code>wss://</code></td></tr><tr><td>是否支持扩展</td><td>扩展性较弱</td><td>支持扩展（子协议、压缩等）</td></tr><tr><td>数据格式</td><td>每次请求携带完整头部</td><td>使用帧（frame），头部小</td></tr><tr><td>网络开销</td><td>较大</td><td>较小</td></tr><tr><td>适合场景</td><td>普通网页请求</td><td>聊天、实时推送、游戏</td></tr></tbody></table><h4 id="WebSocket-的工作过程是什么样的？"><a href="#WebSocket-的工作过程是什么样的？" class="headerlink" title="WebSocket 的工作过程是什么样的？"></a><strong>WebSocket 的工作过程是什么样的？</strong></h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">HTTP 请求<br>    ↓<br>协议升级（<span class="hljs-number">101</span> <span class="hljs-keyword">Switching </span>Protocols）<br>    ↓<br>建立 WebSocket 长连接<br>    ↓<br>双向帧通信<br>    ↓<br>发送关闭帧<br>    ↓<br>关闭 TCP 连接<br></code></pre></td></tr></table></figure><ul><li>WebSocket 首先通过 HTTP 握手请求升级协议，服务器返回 101 状态码表示升级成功。</li><li>之后双方建立一个基于 TCP 的长连接，并通过帧的形式进行双向通信。</li><li>关闭连接时会先发送关闭帧，然后再断开 TCP。</li><li>为了保持连接活跃，通常还会使用心跳机制。</li></ul><h4 id="WebSocket-与短轮询、长轮询的区别（重点）"><a href="#WebSocket-与短轮询、长轮询的区别（重点）" class="headerlink" title="WebSocket 与短轮询、长轮询的区别（重点）"></a><strong>WebSocket 与短轮询、长轮询的区别（重点）</strong></h4><table><thead><tr><th>对比维度</th><th>短轮询</th><th>长轮询</th><th>WebSocket</th></tr></thead><tbody><tr><td>基于协议</td><td>HTTP</td><td>HTTP</td><td>WebSocket（基于 TCP）</td></tr><tr><td>通信模式</td><td>请求-响应</td><td>请求-响应</td><td>全双工</td></tr><tr><td>是否长连接</td><td>否</td><td>半长连接</td><td>是</td></tr><tr><td>实时性</td><td>一般</td><td>较好</td><td>非常好</td></tr><tr><td>服务器能否主动推送</td><td>否</td><td>否（本质仍是响应）</td><td>是</td></tr><tr><td>连接开销</td><td>高（频繁建立）</td><td>中（响应后重建）</td><td>低（持续连接）</td></tr><tr><td>服务器压力</td><td>高</td><td>较高</td><td>相对较低</td></tr><tr><td>实现复杂度</td><td>简单</td><td>中等</td><td>较复杂</td></tr><tr><td>典型场景</td><td>低频刷新</td><td>实时性要求不高的通知</td><td>聊天、IM、实时游戏</td></tr></tbody></table><blockquote><p><strong>短轮询</strong><br>“我每 5 秒问你一次”<br><strong>长轮询</strong><br>“我问你，你没消息就别挂电话，有了再告诉我”<br><strong>WebSocket</strong><br>“我们一直保持通话，随时说话”</p></blockquote><h4 id="SSE-与-WebSocket-有什么区别？"><a href="#SSE-与-WebSocket-有什么区别？" class="headerlink" title="SSE 与 WebSocket 有什么区别？"></a><strong>SSE 与 WebSocket 有什么区别？</strong></h4><table><thead><tr><th>特性</th><th>SSE（Server-Sent Events）</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>通信方式</strong></td><td>单向：服务器 → 客户端</td><td>双向（全双工）：客户端 ↔ 服务器</td></tr><tr><td><strong>底层协议</strong></td><td>基于 HTTP&#x2F;HTTPS，长连接发送事件流</td><td>独立协议 ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F;，通过 HTTP Upgrade 建立连接</td></tr><tr><td><strong>实现复杂度</strong></td><td>简单，浏览器原生 <code>EventSource</code> 支持，开发成本低</td><td>较复杂，需要处理连接管理、心跳和重连逻辑</td></tr><tr><td><strong>断线重连</strong></td><td>浏览器自动支持</td><td>需要手动实现</td></tr><tr><td><strong>数据类型</strong></td><td>主要文本（UTF-8），二进制需编码</td><td>原生支持文本和二进制</td></tr><tr><td><strong>适用场景</strong></td><td>实时推送更新、流式响应，如大型语言模型 API</td><td>实时双向交互，如聊天室、在线游戏、协作应用</td></tr></tbody></table><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a><strong>PING</strong></h3><h4 id="PING-命令的作用是什么？"><a href="#PING-命令的作用是什么？" class="headerlink" title="PING 命令的作用是什么？"></a><strong>PING 命令的作用是什么？</strong></h4><p>PING 是一种常用的网络诊断工具，用于测试主机之间的连通性和网络延迟。通过向目标主机发送 ICMP 请求报文，并接收回应，用户可以判断网络是否畅通以及往返时间（RTT）。</p><h4 id="PING-命令的工作原理是什么？"><a href="#PING-命令的工作原理是什么？" class="headerlink" title="PING 命令的工作原理是什么？"></a><strong>PING 命令的工作原理是什么？</strong></h4><p>PING 基于 <strong>ICMP（Internet Control Message Protocol）</strong> 实现：</p><ol><li>发送 <strong>ICMP Echo Request</strong>（类型 8）到目标主机。</li><li>目标主机若连通，会返回 <strong>ICMP Echo Reply</strong>（类型 0）。</li><li>通过计算请求发送到回应接收的时间，得到往返延迟（RTT）。</li></ol><p>PING 的核心就是通过 ICMP 报文查询主机是否可达，并获取网络性能信息。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><strong>DNS</strong></h3><h4 id="DNS-的作用是什么？"><a href="#DNS-的作用是什么？" class="headerlink" title="DNS 的作用是什么？"></a><strong>DNS 的作用是什么？</strong></h4><ul><li>将域名映射为 IP 地址。</li><li>电脑上一般会保留DNS缓存</li><li>DNS 是 <strong>应用层协议</strong>，可以在 <strong>UDP 或 TCP</strong> 上运行，默认端口为 <strong>53</strong></li></ul><h4 id="DNS-服务器有哪些？根服务器有多少个？"><a href="#DNS-服务器有哪些？根服务器有多少个？" class="headerlink" title="DNS 服务器有哪些？根服务器有多少个？"></a><strong>DNS 服务器有哪些？根服务器有多少个？</strong></h4><ul><li><p>根 DNS：指向 TLD 服务器，全球 13 个 IP 地址，实际部署 1700+ 台。</p></li><li><p>顶级域 DNS (TLD)：管理域名后缀，如 .com、.cn。</p></li><li><p>权威 DNS：存储域名真实 IP，是最终解析源。</p></li><li><p>本地 DNS：ISP 提供的代理服务器，加速解析。</p></li></ul><h4 id="DNS-解析的过程是什么样的？"><a href="#DNS-解析的过程是什么样的？" class="headerlink" title="DNS 解析的过程是什么样的？"></a><strong>DNS 解析的过程是什么样的？</strong></h4><p>完整解析流程较为复杂，可参考专门文章：<a href="https://javaguide.cn/cs-basics/network/dns.html">DNS 域名系统详解（应用层）</a> 。<br>简要流程如下：</p><ol><li>用户发起域名请求 → 浏览器、操作系统、路由器缓存查询。</li><li>缓存未命中 → 本地 DNS 服务器查询。</li><li>本地 DNS 服务器递归查询根 DNS → TLD DNS → 权威 DNS，直到获取域名对应 IP。(或迭代查询)</li><li>返回 IP，浏览器与服务器建立连接。</li></ol><h4 id="DNS-劫持了解吗？如何应对？"><a href="#DNS-劫持了解吗？如何应对？" class="headerlink" title="DNS 劫持了解吗？如何应对？"></a><strong>DNS 劫持了解吗？如何应对？</strong></h4><p>DNS 劫持（DNS Hijacking）是一种网络攻击，通过修改 DNS 解析结果，将用户访问的域名指向错误 IP，导致：</p><ul><li>无法访问正常网站</li><li>被引导至恶意网站</li></ul><p><strong>应对措施</strong>：</p><ul><li>使用可信的 DNS 服务器（如 114.114.114.114、8.8.8.8 等）</li><li>使用 DNS over HTTPS（DoH）或 DNS over TLS（DoT）加密解析</li><li>安装安全防护软件，防止本地 DNS 缓存被篡改</li></ul><h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a><strong>TCP与UDP</strong></h3><h4 id="TCP与UDP区别（重要）"><a href="#TCP与UDP区别（重要）" class="headerlink" title="TCP与UDP区别（重要）"></a><strong>TCP与UDP区别（重要）</strong></h4><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td><strong>连接性</strong></td><td>面向连接</td><td>无连接</td></tr><tr><td><strong>可靠性</strong></td><td>可靠</td><td>不可靠（尽力而为）</td></tr><tr><td><strong>状态维护</strong></td><td>有状态</td><td>无状态</td></tr><tr><td><strong>传输效率</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>传输形式</strong></td><td>面向字节流</td><td>面向数据报（报文）</td></tr><tr><td><strong>头部开销</strong></td><td>20–60 字节</td><td>8 字节</td></tr><tr><td><strong>通信模式</strong></td><td>点对点（单播）</td><td>单播、多播、广播</td></tr><tr><td><strong>常见应用</strong></td><td>HTTP&#x2F;HTTPS、FTP、SMTP、SSH</td><td>DNS、DHCP、SNMP、TFTP、VoIP、视频</td></tr></tbody></table><h4 id="HTTP是基于TCP还是UDP"><a href="#HTTP是基于TCP还是UDP" class="headerlink" title="HTTP是基于TCP还是UDP?"></a><strong>HTTP是基于TCP还是UDP?</strong></h4><ul><li><strong>HTTP&#x2F;1.x 和 HTTP&#x2F;2</strong><ul><li>基于 <strong>TCP</strong> 协议</li><li>TCP 提供可靠、面向连接的传输，确保数据按序无误到达</li><li>发送请求前需要经历 <strong>TCP 三次握手</strong></li><li>TCP 特性可能导致 <strong>队头阻塞（HOL Blocking）</strong>：如果一个报文丢失，整个连接上的其他流都会等待重传</li></ul></li><li><strong>HTTP&#x2F;3</strong><ul><li>弃用 TCP，改用 <strong>QUIC 协议</strong>（基于 UDP）</li><li>解决队头阻塞问题：不同流独立传输，单个流丢包不会影响其他流</li><li>减少连接延迟：QUIC + TLS 1.3 支持 <strong>0-RTT 或 1-RTT</strong> 握手</li><li>更适合高并发、低延迟的网页和流式应用</li></ul></li></ul><blockquote><p>总结：HTTP&#x2F;1.x 和 HTTP&#x2F;2 基于 TCP，HTTP&#x2F;3 基于 UDP 的 QUIC 协议。</p></blockquote><h4 id="有哪些基于-TCP-UDP-的协议？"><a href="#有哪些基于-TCP-UDP-的协议？" class="headerlink" title="有哪些基于 TCP&#x2F;UDP 的协议？"></a><strong>有哪些基于 TCP&#x2F;UDP 的协议？</strong></h4><table><thead><tr><th>传输协议</th><th>应用协议</th><th>主要用途</th><th>特点</th></tr></thead><tbody><tr><td><strong>TCP</strong></td><td>HTTP &#x2F; HTTPS</td><td>网页传输</td><td>可靠、有序，HTTPS 增加 TLS 加密</td></tr><tr><td></td><td>FTP &#x2F; SFTP &#x2F; FTPS</td><td>文件传输</td><td>可靠传输，SFTP&#x2F;FTPS 提供加密</td></tr><tr><td></td><td>SMTP</td><td>发送邮件</td><td>可通过 STARTTLS 加密</td></tr><tr><td></td><td>POP3 &#x2F; POP3S</td><td>接收邮件</td><td>下载邮件到本地，POP3S 为加密版本</td></tr><tr><td></td><td>IMAP &#x2F; IMAPS</td><td>管理邮件</td><td>邮件保留在服务器，多设备同步</td></tr><tr><td></td><td>Telnet</td><td>远程登录</td><td>明文传输，不安全</td></tr><tr><td></td><td>SSH</td><td>安全远程管理</td><td>加密远程登录与命令执行，替代 Telnet</td></tr><tr><td><strong>UDP</strong></td><td>HTTP&#x2F;3 (QUIC)</td><td>网页传输</td><td>基于 UDP 的 QUIC 协议，减少延迟，支持 0-RTT</td></tr><tr><td></td><td>DHCP</td><td>动态分配 IP</td><td>自动获取 IP、子网掩码、网关、DNS</td></tr><tr><td></td><td>DNS</td><td>域名解析</td><td>通常用 UDP 快速查询，大响应或区域传送会切换 TCP</td></tr><tr><td></td><td>RTP &#x2F; RTCP</td><td>实时音视频</td><td>低延迟，允许少量丢包，RTCP 提供质量监控</td></tr><tr><td></td><td>TFTP</td><td>简单文件传输</td><td>小文件传输，常用于局域网设备升级</td></tr><tr><td></td><td>SNMP</td><td>网络管理</td><td>查询与修改网络设备状态</td></tr><tr><td></td><td>NTP</td><td>时间同步</td><td>保证网络计算机时间一致</td></tr></tbody></table><h4 id="TCP-三次握手和四次挥手（非常重要）"><a href="#TCP-三次握手和四次挥手（非常重要）" class="headerlink" title="TCP 三次握手和四次挥手（非常重要）"></a><strong>TCP 三次握手和四次挥手（非常重要）</strong></h4><p><img src="/img/tcp-shakes-hands-three-times-1770975545427-6.png" alt="tcp-shakes-hands-three-times"><img src="/img/tcp-waves-four-times.png" alt="tcp-waves-four-times"></p><h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><ul><li>目的是建立可靠的双向连接，确保 <strong>双方都能发送和接收数据</strong>。</li><li>第一次握手：客户端告诉服务器“我要建立连接”，并发送序列号。</li><li>第二次握手：服务器确认客户端能接收数据，同时告诉客户端自己也准备好了。</li><li>第三次握手：客户端确认服务器可接收数据，连接正式建立。</li><li><strong>总结</strong>：三次保证双方的发送&#x2F;接收能力都确认到位，防止半连接。</li></ul><hr><h5 id="第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第二次握手传回了 ACK，为什么还要传回 SYN？"></a>第二次握手传回了 ACK，为什么还要传回 SYN？</h5><ul><li>第二次握手是服务器对客户端的 SYN 做 ACK <strong>并且</strong>告诉客户端自己也有序列号要发送（SYN）。</li><li>如果只传 ACK，服务器的序列号还没有告诉客户端，客户端不能确认服务器也能发送数据。</li></ul><hr><h5 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h5><ul><li>TCP 连接是全双工的，客户端和服务器可以独立关闭各自的发送方向。</li><li>第一次挥手：客户端说“我发送完了”（FIN）。</li><li>第二次挥手：服务器确认客户端 FIN（ACK）。</li><li>第三次挥手：服务器说“我也发送完了”（FIN）。</li><li>第四次挥手：客户端确认服务器 FIN（ACK）。</li><li><strong>总结</strong>：四次保证双方都能独立关闭发送方向，防止数据丢失。</li></ul><hr><h5 id="为什么不能把服务器发送的-ACK-和-FIN-合并成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并成三次挥手？</h5><ul><li>因为服务器可能还有数据未发送，如果直接合并 ACK + FIN，可能导致客户端过早关闭，服务器的数据还没发送完。</li><li>分开保证 <strong>可靠关闭</strong>，先 ACK 客户端 FIN，再 FIN 自己的数据。</li></ul><hr><h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><ul><li>客户端在 <strong>TIME_WAIT</strong> 状态会等待一段时间，超时会重发 FIN。</li><li>服务器收到重复 FIN 后，会重新发送 ACK，保证可靠关闭。</li><li><strong>总结</strong>：TCP 保证任何丢失的报文都能被重新确认。</li></ul><hr><h5 id="为什么第四次挥手客户端需要等待-2×MSL-才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2×MSL-才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2×MSL 才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2×MSL 才进入 CLOSED 状态？</h5><ul><li>MSL（Maximum Segment Lifetime）是报文在网络中的最长寿命。</li><li>等待 2×MSL 可以保证：<ol><li>网络中残留的报文不会干扰后续新的连接。</li><li>如果服务器没有收到客户端最后的 ACK，客户端还能重发 ACK，保证服务器可靠关闭。</li></ol></li></ul><h4 id="TCP-如何保证传输的可靠性？（重要）"><a href="#TCP-如何保证传输的可靠性？（重要）" class="headerlink" title="TCP 如何保证传输的可靠性？（重要）"></a><strong>TCP 如何保证传输的可靠性？（重要）</strong></h4><h5 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h5><ul><li><strong>序列号</strong>：每个字节都有唯一序列号，接收方按序重组数据。</li><li><strong>确认应答（ACK）</strong>：接收方确认已收到数据。</li><li><strong>重传机制</strong>：未收到 ACK 的数据会重传，支持快速重传。</li><li><strong>流量控制 + 拥塞控制</strong>：防止接收方处理不过来或网络拥塞导致丢包。</li></ul><hr><h5 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="TCP 如何实现流量控制？"></a>TCP 如何实现流量控制？</h5><ul><li>使用 <strong>滑动窗口（Window）机制</strong>：<ul><li>接收方通过窗口大小告知发送方自己能接收的数据量。</li><li>发送方根据窗口大小控制发送速率，防止接收方缓存溢出。</li></ul></li></ul><hr><h5 id="TCP-的拥塞控制怎么实现？"><a href="#TCP-的拥塞控制怎么实现？" class="headerlink" title="TCP 的拥塞控制怎么实现？"></a>TCP 的拥塞控制怎么实现？</h5><p><img src="/img/tcp-congestion-control.png" alt="tcp-congestion-control"></p><ul><li>动态调整发送速率，防止网络拥塞。</li><li>核心算法：<ol><li><strong>慢开始（Slow Start）</strong>：初始窗口指数增长。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：线性增长窗口，平稳发送。</li><li><strong>快速重传（Fast Retransmit）</strong>：收到重复 ACK 时立即重传丢失报文。</li><li><strong>快速恢复（Fast Recovery）</strong>：丢包后调整窗口继续传输，避免回退到慢开始。</li></ol></li></ul><hr><h5 id="ARQ-协议（Automatic-Repeat-reQuest）"><a href="#ARQ-协议（Automatic-Repeat-reQuest）" class="headerlink" title="ARQ 协议（Automatic Repeat reQuest）"></a>ARQ 协议（Automatic Repeat reQuest）</h5><ul><li>自动重传请求协议，用于保证可靠传输。</li><li><strong>类型</strong>：<ol><li><strong>停止等待 ARQ（Stop-and-Wait ARQ）</strong><ul><li>发送方发送一个数据包后等待确认，再发送下一个。</li><li>简单，但效率低。</li></ul></li><li><strong>连续 ARQ（Sliding Window &#x2F; Go-Back-N, Selective Repeat）</strong><ul><li>发送方可以连续发送多个数据包，无需等待每个 ACK。</li><li>Go-Back-N：出错包之后的数据全部重传。</li><li>Selective Repeat：只重传出错的包，效率更高。</li></ul></li></ol></li></ul><hr><h5 id="超时重传如何实现？"><a href="#超时重传如何实现？" class="headerlink" title="超时重传如何实现？"></a>超时重传如何实现？</h5><ul><li>发送方设置 <strong>定时器</strong>，若超时未收到 ACK，则重传该数据包。</li></ul><h5 id="超时重传时间（RTO-Retransmission-Timeout）如何确定？"><a href="#超时重传时间（RTO-Retransmission-Timeout）如何确定？" class="headerlink" title="超时重传时间（RTO, Retransmission Timeout）如何确定？"></a>超时重传时间（RTO, Retransmission Timeout）如何确定？</h5><ul><li>根据 <strong>往返时间 RTT（Round Trip Time）</strong> 动态计算。</li><li>自适应调整，保证既不频繁重传，也不等待过久。</li></ul><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><h4 id="IP协议的作用是什么？"><a href="#IP协议的作用是什么？" class="headerlink" title="IP协议的作用是什么？"></a><strong>IP协议的作用是什么？</strong></h4><p>IP（Internet Protocol）是 <strong>网络层协议</strong>，负责将数据包从源主机传输到目标主机，通过 <strong>逻辑地址（IP 地址）</strong> 定位设备。</p><h4 id="什么是IP地址？IP寻址如何工作？"><a href="#什么是IP地址？IP寻址如何工作？" class="headerlink" title="什么是IP地址？IP寻址如何工作？"></a><strong>什么是IP地址？IP寻址如何工作？</strong></h4><ul><li><strong>IP 地址</strong>是互联网上设备的唯一标识，用于定位和寻址。</li><li><strong>IP 寻址</strong>：发送方将数据封装成 IP 数据包，路由器根据目标 IP 地址转发，直到到达目的主机。</li></ul><h4 id="什么是-IP-地址过滤？"><a href="#什么是-IP-地址过滤？" class="headerlink" title="什么是 IP 地址过滤？"></a><strong>什么是 IP 地址过滤？</strong></h4><p>IP 地址过滤（IP Filtering）通过允许或拒绝特定 IP 地址访问网络，实现安全控制和防火墙策略。</p><h4 id="IPv4-和-IPv6-有什么区别？"><a href="#IPv4-和-IPv6-有什么区别？" class="headerlink" title="IPv4 和 IPv6 有什么区别？"></a><strong>IPv4 和 IPv6 有什么区别？</strong></h4><table><thead><tr><th>特性</th><th>IPv4</th><th>IPv6</th></tr></thead><tbody><tr><td>地址长度</td><td>32 位</td><td>128 位</td></tr><tr><td>地址格式</td><td>点分十进制（如 192.168.0.1）</td><td>冒号十六进制（如 2001:0db8::1）</td></tr><tr><td>地址空间</td><td>≈42亿</td><td>≈3.4×10³⁸，几乎无限</td></tr><tr><td>支持特性</td><td>不支持内置加密</td><td>内置 IPsec、简化报文头、自动配置</td></tr><tr><td>NAT</td><td>常用</td><td>不再依赖 NAT，端到端可达</td></tr></tbody></table><h4 id="如何获取客户端真实-IP？"><a href="#如何获取客户端真实-IP？" class="headerlink" title="如何获取客户端真实 IP？"></a><strong>如何获取客户端真实 IP？</strong></h4><p>获取客户端真实 IP 主要有三种方法：</p><blockquote><p><strong>应用层方法</strong></p><ul><li>通过 <strong><code>X-Forwarded-For</code></strong> 请求头获取客户端 IP。</li></ul><p><strong>传输层方法</strong></p><ul><li>利用 <strong>TCP Options</strong> 或 <strong>Proxy Protocol</strong> 传递客户端真实 IP。</li></ul><p><strong>网络层方法</strong></p><ul><li>通过 <strong>隧道 + DSR（Direct Server Return）模式</strong>获取真实 IP。</li></ul></blockquote><h4 id="NAT-的作用是什么？"><a href="#NAT-的作用是什么？" class="headerlink" title="NAT 的作用是什么？"></a><strong>NAT 的作用是什么？</strong></h4><p>NAT（Network Address Translation，网络地址转换）将 <strong>私有 IP 与公网 IP 映射</strong>，实现：</p><ul><li>节省 IPv4 地址</li><li>内网设备共享公网访问</li><li>提高网络安全性，隐藏内网结构</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><h4 id="什么是Mac地址"><a href="#什么是Mac地址" class="headerlink" title="什么是Mac地址"></a><strong>什么是Mac地址</strong></h4><ul><li><p>MAC（Media Access Control）地址是 <strong>网卡的硬件唯一标识</strong>。</p></li><li><p>长度为 48 位，通常用 <strong>十六进制表示</strong>（如 <code>00:1A:2B:3C:4D:5E</code>）。</p></li><li><p>用于 <strong>局域网内设备间通信</strong>，由硬件厂商分配，不随 IP 地址改变。</p></li></ul><h4 id="ARP协议解决了什么问题"><a href="#ARP协议解决了什么问题" class="headerlink" title="ARP协议解决了什么问题"></a><strong>ARP协议解决了什么问题</strong></h4><ul><li><p>网络层使用 <strong>逻辑地址（IP）</strong> 通信，但数据链路层需要 <strong>物理地址（MAC）</strong>。</p></li><li><p><strong>ARP（Address Resolution Protocol）</strong> 负责将 IP 地址解析为对应的 MAC 地址，实现 <strong>局域网内的数据传输</strong>。</p></li></ul><h4 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a><strong>ARP协议的工作原理</strong></h4><h5 id="同一局域网内的-MAC-寻址"><a href="#同一局域网内的-MAC-寻址" class="headerlink" title="同一局域网内的 MAC 寻址"></a>同一局域网内的 MAC 寻址</h5><ul><li><strong>目的</strong>：找到目标 IP 对应的 MAC 地址，实现局域网内直接通信。</li><li><strong>流程</strong>：<ol><li>主机 A 想发送数据到同一局域网内的 IP B，但不知道 MAC。</li><li>A <strong>广播 ARP 请求</strong>：谁拥有 IP B，请回复 MAC。</li><li>IP B 的主机收到请求后，发送 <strong>ARP 响应</strong>（单播给 A）告知自己的 MAC。</li><li>A 缓存 B 的 MAC，后续通信直接使用。</li></ol></li></ul><h5 id="不同局域网内的-MAC-寻址"><a href="#不同局域网内的-MAC-寻址" class="headerlink" title="不同局域网内的 MAC 寻址"></a>不同局域网内的 MAC 寻址</h5><ul><li><strong>目的</strong>：跨网段通信，局域网无法直接找到远端主机 MAC。</li><li><strong>流程</strong>：<ol><li>主机 A 想发送数据到不同网段 IP B。</li><li>A 检查目标 IP，不在同一子网。</li><li>A 将数据发送给 <strong>默认网关（路由器）的 MAC）</strong>。</li><li>路由器负责转发到目标网段，再通过目标局域网的 ARP 获取目标主机 MAC。</li></ol></li></ul><blockquote><p><strong>总结</strong>：</p><ul><li><strong>同一局域网</strong>：ARP 广播直接找到目标 MAC。</li><li><strong>跨局域网</strong>：ARP 只找到网关 MAC，由网关负责转发到目标。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软高级软件设计期末复习</title>
    <link href="/2026/02/10/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/10/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>高级软件设计简答题汇总</p><p><strong>设计模式和类库有什么不同</strong></p><ul><li><p>定义与目的</p><blockquote><p>解决问题，重复使用的框架，经过验证的最佳实践，解决设计问题</p><p>封装特定功能的类和接口的集合，提供具体实现</p></blockquote></li><li><p>抽象级别</p><blockquote><p>更高级别抽象，方法论，组织代码和模块</p><p>具体实现，提供可直接使用的代码</p></blockquote></li><li><p>通用性和使用范围</p><blockquote><p>通用性更高，适合多种语言和项目，举例</p><p>类库与特定编程语言绑定，Java Spring框架</p></blockquote></li><li><p>重用程度</p><blockquote><p>重用思想和方法，而非代码</p><p>重用代码</p></blockquote></li></ul><p><strong>工厂设计模式的三个OO原则</strong></p><ul><li><p>单一职责原则</p><blockquote><p>一个类应当只有一个引起变化的原因。创建对象的职责被分配给专门的工厂，可以将创建与使用分离。</p><p>工厂只关心对象的创建，而不关心对象的具体使用。</p></blockquote></li><li><p>依赖倒置原则</p><blockquote><p>高层模块不应当依赖于底层模块，都应该依赖于抽象。</p><p>抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>客户端代码依赖于抽象的工厂，而不依赖于具体的工厂实现类。</p></blockquote></li><li><p>开闭原则</p><blockquote><p>软件实体应当对扩展开放，对修改封闭。工厂方法模式允许系统不修改代码，引入新类型的对象，可以添加新的工厂扩展系统。</p></blockquote></li></ul><p><strong>什么是设计模式，什么是design pattern catalog？</strong></p><ul><li><p>在软件工程中，针对特定问题的典型解决方案的一种标准化描述。最佳实践，解决问题，不是代码，而是指导方案</p><blockquote><p>包含模式名称、问题、解决方案、效果</p><p>分三大类：创建型、结构型、行为型</p></blockquote></li><li><p>Design pattern catalog 是指收集多种设计模式的目录。包含详细描述、示例、优缺点。</p></li></ul><p><strong>为什么“依赖倒置原则”被认为是大多数设计模式的核心？</strong></p><ul><li>先介绍依赖倒置原则，高层不应依赖低层，应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li><li>降低模块之间的耦合。</li></ul><p><strong>比较策略模式和状态模式</strong></p><ul><li><p>都是行为型设计模式，然后从目的、应用场景、实现、优缺点来讲</p><blockquote><p><strong>目的</strong>：策略模式允许运行时选择算法或行为，状态模式允许对象改变内部状态来改变行为</p><p><strong>应用场景</strong>：</p><p>策略模式</p><ul><li>用于多种类似算法或行为的互换使用（不同排序算法），运行时可切换</li><li>避免条件语句，去除条件语句决定执行哪个算法</li><li>封装算法的变化</li></ul><p>状态模式</p><ul><li>对象行为依赖于其状态，行为随着状态改变而改变</li><li>对象有复杂的状态逻辑，状态转换明确</li><li>避免对象行为的膨胀</li></ul><p><strong>实现</strong>：</p><ul><li>策略模式定义策略接口，创建具体策略类，上下文使用策略接口作为字段，调用具体策略实现</li><li>状态模式将每种状态封装成独立的类，将状态转换的逻辑放在状态类内部实现</li></ul><p><strong>优缺点</strong>：</p><ul><li>策略模式提高复用性，独立于客户端变化，但需了解策略之间差异，增加了复杂性</li><li>状态模式将逻辑分散到状态类中，易于扩展状态，但引入很多状态类，增加系统复杂性</li></ul></blockquote></li></ul><p><strong>比较适配器、外观和装饰器设计模式的意图和模式</strong></p><ul><li>适配器模式将一个类的接口转换成期望的另一个类的接口，让不兼容的类一起工作（整合第三方库）</li><li>外观模式提供统一的接口，访问子系统的一群接口，使子系统更易使用（简化客户端与复杂系统的交互）</li><li>装饰器模式动态地给对象添加额外的职责而不改变对象接口，比生成子类灵活（动态添加功能）</li></ul><p><strong>比较适配器模式、装饰器模式和代理模式的目的与结构差异。</strong></p><ul><li><p>都是结构型设计模式，然后写目的和结构</p><blockquote><p>适配器模式的目的是解决接口不兼容问题，通过包装已有对象将其接口转换为客户端期望的接口</p><p>装饰器模式的目的是在不修改原对象的情况下动态地为对象增加功能，其结构呈现<strong>链式包装</strong></p><p>代理模式的目的是控制对对象的访问，在客户端与真实对象之间提供一个代理层。</p><p>三者在结构上都通过<strong>组合方式</strong>包装对象，</p></blockquote></li></ul><p><strong>比较透明组合和安全组合。</strong></p><ul><li><p>讲定义和优缺点</p><blockquote><p><strong>定义</strong>：透明组合的Component中包含管理子部件的操作，对于Leaf节点和Composite节点都可见。而安全组合管理子部件的操作不再Component接口中定义，而是只在Composite节点类中实现。</p><p><strong>优缺点</strong>：</p><p>透明组合客户端通义对待叶节点和容器节点，不必关心操作的是哪个。但牺牲了单一职责原则，叶节点包含多余的操作可能引起运行时错误。</p><p>安全组合叶节点不提供无关的操作，遵循单一职责原则，更加安全。但牺牲了透明性，处理节点要进行类型判断，增加了代码的复杂性。</p></blockquote></li></ul><p><strong>比较工厂方法模式与抽象工厂模式的适用场景。</strong></p><ul><li>工厂方法模式适用于系统只涉及一种产品类型，子类决定创建哪种产品，产品之间没有强关联（不同类型的解析器）</li><li>抽象工厂模式适用于创建一组相关或相互依赖产品族的产品族的场景，强调产品一致性（不同风格的UI组件）</li></ul><p><strong>比较组合模式与装饰模式在结构上的异同。</strong></p><ul><li>相同点：都使用抽象组件（Component），都通过递归方式组合对象，而不是继承。</li><li>不同点：Composite中包含多个Component，而Decorator中只包装一个Component。组合模式关注层次结构，形成树结构，而装饰模式关注功能扩展，形成链式结构。</li></ul><p><strong>说明装饰者模式如何体现开闭原则和合成复用原则。</strong></p><ul><li>先扯两个概念。</li><li>开闭原则：装饰者模式通过引入装饰类在不修改原有类的情况下动态扩展对象功能，完美体现了开闭原则。</li><li>合成复用原则：通过对象组合实现功能扩展，避免了继承带来的类爆炸问题，符合合成复用原则。</li></ul><p><strong>说明观察者模式如何体现依赖倒置原则与迪米特法则。</strong></p><ul><li>先扯概念</li><li>主题和观察者通过抽象接口解耦，高层模块 Subject 不再依赖具体实现，体现依赖倒置原则。</li><li>主题对象只与观察者接口通信，不与观察者的具体实现发生依赖，符合迪米特法则。</li></ul><p><strong>说明模板方法模式如何体现开闭原则。</strong></p><ul><li>开闭原则定义</li><li>模板方法模式通过固定算法骨架、延迟步骤实现，使系统在不修改算法结构的前提下即可扩展新行为，从而体现了开闭原则。</li></ul><p><strong>说明组合模式如何体现里氏替换原则。</strong></p><ul><li>组合模式通过为叶子对象和组合对象定义统一的抽象组件接口，使客户端对单个对象和组合对象的使用具有一致性，从而保证了任何组件子类对象都可以替换抽象组件出现的位置而不影响程序行为，体现了里氏替换原则。</li></ul><p><strong>观察者模式中的update方法是否必须？请说明理由。</strong></p><ul><li>观察者模式中的update方法通常是必须的</li><li>先讲角色：观察者（Observer）和被观察者（Subject）。被观察者维护一个观察者列表，并在状态变化时通知它们。观察者需要有一个方法来接收并响应这些通知，这就是 update 方法的作用。通过 update 方法，观察者可以得知被观察者的状态变化并作出相应的反应。</li><li>再讲通知方式：当被观察者的状态改变时，它会调用每个注册观察者的 update 方法，以此来通知观察者其状态已改变。</li><li>灵活性与一致性：在某些实现中，update 方法可以接收参数以提供关于状态变化的更多信息。</li><li>update概念上必需，但具体形式并非固定，可以通过回调、事件机制等方式实现通知。</li></ul><p><strong>在什么情况下应当使用策略模式？举例说明。</strong></p><ul><li>用于多种类似算法或行为的互换使用（不同排序算法），运行时可切换</li><li>避免条件语句，去除条件语句决定执行哪个算法</li><li>封装算法的变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>高级软件设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软统计模型期末复习</title>
    <link href="/2026/02/06/2024%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/06/2024%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文为2024统计模型期末试卷回忆版，既作为课程复习笔记，也希望通过系统梳理，加深对算法思想与应用场景的认识。</p><ul><li>其中，简答题8道＋计算题5道</li><li>2024版简答题新增了部分我认为会考的内容作为复习，所以有12道，实际只有8道</li><li>2025统计模型计算题新增了 <code>Γ函数</code> 作为考点，其他的题目大同小异。</li><li>回忆版仅供参考。</li></ul><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul><li><strong>简述 EM 算法的基本思想、主要步骤，并说明其优缺点与应用场景。</strong></li><li><strong>何为聚类？简述 K-means 聚类算法的基本流程及其优缺点。</strong></li><li><strong>什么是层次聚类？写出两种常用的簇间距离计算方法及其变种。</strong></li><li><strong>简述分类问题中的：二分类、多分类、多标签分类与排序问题的区别及应用场景。</strong></li><li><strong>简述训练集、验证集、测试集在分类问题中的作用与区别。</strong></li><li><strong>简述决策树分类算法，并说明 C4.5 相比 ID3 的主要改进。</strong></li><li><strong>给出泊松分布的概率密度函数，描述参数k和的含义。</strong></li><li><strong>给出正态分布的概率密度函数，以及均值和方差。</strong></li><li><strong>写出四种常见概率分布（二项分布、Poisson、指数、正态），并说明各自应用场景。</strong></li><li><strong>什么是 N-Gram 模型？解释 Unigram、Bigram、Trigram，并说明其在语言建模中的作用。</strong></li><li><strong>给出NLP的典型任务，以及其特征应用。</strong></li><li><strong>什么是词项-文档矩阵，如何构造？</strong></li></ul><h2 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h2><ul><li><h3 id="K-means-聚类算法计算"><a href="#K-means-聚类算法计算" class="headerlink" title="K-means 聚类算法计算"></a><strong>K-means 聚类算法计算</strong></h3><blockquote><p>给定如下样本点：<br>A(1,1)，B(2,1)，C(5,4)，D(6,5)<br>初始聚类中心为 μ₁(1,1)，μ₂(5,4)。</p></blockquote><p>请完成 <strong>第一次 K-means 迭代</strong>：<br> ① 样本分配<br> ② 计算新的聚类中心</p><p><img src="/img/stat-model/image-20260101212137596.png" alt="image-20260101212137596"></p></li><li><h3 id="正态分布极大似然估计"><a href="#正态分布极大似然估计" class="headerlink" title="正态分布极大似然估计"></a><strong>正态分布极大似然估计</strong></h3><blockquote><p>给定样本 x1,x2,…,xn来自正态分布 N(μ,σ2)</p></blockquote><p>① 写出似然函数hexo clean<br>② 写出对数似然函数<br>③ 对参数求偏导，给出 μ 和 σ2 的极大似然估计值</p><p><img src="/img/stat-model/image-20260101212150711.png" alt="image-20260101212150711"></p></li><li><h3 id="朴素贝叶斯分类计算"><a href="#朴素贝叶斯分类计算" class="headerlink" title="朴素贝叶斯分类计算"></a><strong>朴素贝叶斯分类计算</strong></h3><blockquote><p>已知某分类问题中先验概率和条件概率如下：</p><p>P(C1)&#x3D;0.6,  P(C2)&#x3D;0.4<br>P(x∣C1)&#x3D;0.2,  P(x∣C2)&#x3D;0.5</p></blockquote><p>使用<strong>全概率公式</strong>计算后验概率 P(C1∣x) 与 P(C2∣x) ，并给出分类结果。</p><p><img src="/img/stat-model/image-20260101212204905.png" alt="image-20260101212204905"></p></li><li><h3 id="Bigram-语言模型计算"><a href="#Bigram-语言模型计算" class="headerlink" title="Bigram 语言模型计算"></a><strong>Bigram 语言模型计算</strong></h3><blockquote><p>语料为：<br><code>I love machine learning</code></p></blockquote><p>① 写出该句子的 Bigram 表示<br>② 计算句子概率</p><p><img src="/img/stat-model/image-20260101212216578.png" alt="image-20260101212216578"></p></li><li><h3 id="词袋模型计算"><a href="#词袋模型计算" class="headerlink" title="词袋模型计算"></a><strong>词袋模型计算</strong></h3><blockquote><p>给定语料库：<br>文档1：<code>I love NLP</code><br>文档2：<code>I love machine learning</code></p></blockquote><p>① 构建词汇表<br>② 构造对应的词项–文档矩阵</p><p><img src="/img/stat-model/image-20260101212254957.png" alt="image-20260101212254957"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计模型</tag>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025南软软件安全期末复习</title>
    <link href="/2026/02/06/%E5%8D%97%E8%BD%AF%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2026/02/06/%E5%8D%97%E8%BD%AF%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文是对《软件安全》课程期末内容的系统性复习与梳理，围绕软件漏洞、恶意代码、安全开发生命周期（SDL）、安全需求与设计、软件版权与法律等核心知识点，对教材中的重点概念、常见考点和易混淆内容进行了整理与归纳。</p><p>​2025冷门考点：威胁建模、 Windows安全漏洞保护的基本技术及其存在的问题</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><p><strong>什么是零日(0day)漏洞?什么是零日(0day)攻击?</strong>（2024）</p><blockquote><p>未公开披露的软件漏洞，没有给软件厂商时间去打补丁或给出解决方案。</p><p>攻击者利用零日漏洞开发攻击工具攻击</p></blockquote></li><li><p>为什么说面对当前的全球网络空间安全威胁，必须对软件安全给予强烈关注?</p><blockquote><p>背景：软件无处不在</p><p>问题：漏洞普遍存在</p><p>结论：重视软件安全</p></blockquote></li><li><p>当前，黑客为了能够有效达到窃取数据、破坏系统的目的，常常通过挖掘或是购买零日漏洞，开发针对零日漏洞的攻击工具，零日漏洞威胁实际上反映了软件系统存在的一个什么问题?</p><blockquote><p>先介绍零日漏洞</p><p>系统的脆弱性，漏洞的隐秘性，修复的滞后性</p></blockquote></li><li><p>根据本书的介绍，软件安全威胁可以分为哪几类?</p><blockquote><p>软件漏洞、恶意代码、软件侵权</p></blockquote></li><li><p>试谈谈对软件漏洞的认识，举出软件漏洞造成危害的事件例子。</p><blockquote><p>软件生命周期与安全相关的设计错误、编码缺陷和运行故障</p><p>举例两方面：</p><p>软件漏洞在运行期间造成错误、崩溃、死机：操作系统蓝屏、内存泄漏崩溃</p><p>软件漏洞被黑客利用攻击：数据库获取明文口令、缓冲区溢出攻击获得远程权限</p></blockquote></li><li><p>什么是恶意代码?除了传统的计算机病毒,还有哪些恶意代码类型?</p><blockquote><p>未授权，搞破坏</p><p>蠕虫、特洛伊木马、后门、勒索软件…</p></blockquote></li><li><p>针对软件的版权，有哪些侵权行为?</p><blockquote><p>未经许可，发表，登记，修改，翻译</p><p>复制、部分复制</p><p>合作软件独立发表</p><p>向公众发行、出租、传播</p><p>转让他人著作权</p></blockquote></li><li><p>谈谈对软件安全概念的理解。</p><blockquote><p>提供系统方法标识、追踪危害性软件，缓解和控制</p><p>三大属性CIA：保密性、完整性、可用性</p><p>其他属性：可认证，审计..</p></blockquote></li><li><p>简述软件和软件工程的概念。</p><blockquote><p>计算机程序、数据和相关文档</p><p>工程方法开发维护软件，结合好技术，高效开发，是技术和管理结合的工程学科</p></blockquote></li><li><p>对照一般软件工程的概念，软件安全工程主要增添了哪些任务</p><blockquote><p>安全代码、安全环境、安全测试、网络安全、安全维护、安全标准、安全审计</p></blockquote></li><li><p>谈谈软件安全与软件危机、软件质量和软件质量保证、软件保障、软件可靠性、应用软件系统安全、可信软件和软件定义安全等概念的区别和联系。</p><blockquote><p>给了</p></blockquote></li><li><p>确保软件安全的基本思路是什么?软件安全涉及的技术主要有哪些方面?</p><blockquote><p>挖掘安全漏洞，分析给出修复</p><p>事先分析可能发生的原因，开发中规避</p><p>软件安全属性认知、信息系统安全工程、软件安全开发（背不出来也给了）</p></blockquote></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ul><li><p><strong>试述软件漏洞的概念，谈谈软件漏洞与软件错误、软件缺陷、软件 Bug 的区别与联系。</strong>（2024）</p><blockquote><p>讲讲软件漏洞定义（同上）</p><p>错误存在软件开发生命周期中（需求、设计、编码错误一堆错误），缺陷&#x2F;bug存在软件产品中（静态）</p></blockquote></li><li><p>为什么说安全缺陷或者说Bug是一个需要考虑具体环境、具体对象的概念?</p><blockquote><p>举例Https</p><p>讲讲安全性需求是否需要加入考量，然后说具体问题具体分析</p></blockquote></li><li><p>试分析软件漏洞的成因。</p><blockquote><p>看到成因，刨根问底</p><p>系统结构、软件大型化复杂化、使用场景、缺乏重视</p></blockquote></li><li><p>软件漏洞如何分类分级管理?</p><blockquote><p>成因类：</p><p>利用位置类：</p><p>威胁类型类：</p><p>严重级</p><p>漏洞评分系统级</p></blockquote></li><li><p>软件漏洞买卖合法吗?软件漏洞应当如何管控?</p><blockquote><p>不合法</p><p>认清并加以重视（漏洞）</p><p>限制并获得双赢（”白帽”）</p><p>加强法律建设</p></blockquote></li><li><p>厂商发布漏洞信息的标准过程是怎样的?</p><blockquote><p>识别、评估、选择补救措施、发布</p></blockquote></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ul><li><p>程序运行时的内存布局是怎样的?</p><blockquote><p>栈堆代数，中心扩散，上低下高</p></blockquote></li><li><p>在程序运行时，用来动态申请分配数据和对象的内存区域形式称为什么?</p><blockquote><p>堆</p></blockquote></li><li><p><strong>什么是缓冲区溢出漏洞?</strong></p><blockquote><p>向缓冲区写数据时未作边界检查，导致超过预先分配的边界，覆盖合法数据</p><p>黑客利用缓冲区溢出攻击，获取系统权限</p></blockquote></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul><li><p>什么是软件的生命周期?软件生命周期通常包括哪几个阶段?</p><blockquote><p>定义、开发、维护</p><p>定义：问题定义、可行性分析、需求分析</p><p>开发：设计、编码、测试</p><p>维护</p></blockquote></li><li><p>什么是软件过程？什么是软件开发（过程）模型？为什么从20世纪90年代以后，人们更多使用“软件过程”来替代传统的“软件开发模型”？（难背）</p><blockquote><p>获得高质量软件完成任务的框架，规定工作步骤</p><p>软件生命周期开发、运行、维护的全部工作任务的框架</p><p>更高效、更灵活、更高精度、减少质量问题、团队</p></blockquote></li><li><p>有哪些典型的软件开发模型？这些软件开发模型有什么区别与联系？</p><blockquote><p>螺旋、原型、瀑布、敏捷、增量、喷泉</p><p>迭代次数和时机、开发时间</p><p>影响开发过程与时机</p></blockquote></li><li><p><strong>SD3+C原则是SDL模型实施的基本原则，试简述其内容。</strong></p><blockquote><p>安全设计、安全配置、安全部署、沟通</p></blockquote></li><li><p>微软的SDL模型与传统的瀑布模型的关系是怎样的?</p><blockquote><p>发展而来，增加两个活动（安全和业务）</p></blockquote></li><li><p><strong>什么是敏捷SDL？敏捷SDL和经典SDL的主要区别是什么？</strong>（2024、2025）</p><blockquote><p>无阶段的迭代开发模型</p><p>并不是每个发布版本都要达到所有要求</p></blockquote></li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ul><li><p>为什么要进行需求分析?通常对软件系统有哪些需求?</p><blockquote><p>了解用户需求，需求分析是前提</p><p>功能、性能、质量属性、接口、约束</p></blockquote></li><li><p>为什么要进行安全需求分析?通常对软件系统有哪些安全需求?</p><blockquote><p>如何提高安全质量，减少安全漏洞</p><p>外部：法规、合规性、对策总结</p><p>内部：组织内部标准、指南，功能相关的安全需求</p></blockquote></li><li><p>软件安全需求分析的主要工作是什么?它和软件需求分析有什么区别与联系?</p><blockquote><p>在需求分析阶段，确定环境，了解安全需求内容，通过安全需求获取过程，分析安全需求</p><p>安全需求是客观的、安全需求从系统角度分析、按需采纳</p><p>是衍生、以功能性需求分析为基础、帮助从安全角度确定系统需求</p></blockquote></li><li><p>为什么说软件安全需求更多地来源于遵从性需求?</p><blockquote><p>用户难以提出，来自内外部安全政策和标准的遵从</p></blockquote></li><li><p>软件安全需求的获取方法有哪些?</p><blockquote><p>头脑风暴、问卷与访谈、策略分解、数据分类、主客体关系矩阵</p></blockquote></li><li><p><strong>软件安全需求的获取方法中的策略分解是指什么?</strong>（2024）</p><blockquote><p>将需遵守的内外部政策，分解成详细的安全需求</p></blockquote></li><li><p>软件安全需求的获取方法中的数据分类是指什么?</p><blockquote><p>按数据生命周期对数据分阶段划分、按数据重要性对保护级别划分</p></blockquote></li><li><p>软件安全需求的获取方法中的主&#x2F;客体关系矩阵是指什么?</p><blockquote><p>刻画基于使用用例的主客体操作关系，角色（列）与组件（行）的二维表示，与矩阵所允许的对应动作相违背的判定为威胁</p></blockquote></li><li><p>针对信息系统中的数据生命周期，通常应当考虑的安全需求有哪些?</p><blockquote><p>创建、处理、传输、存储、介质、归档</p><p>数据创建、访问和权限</p><p>数据泄漏保护</p><p>传输数据安全协议</p><p>数据存储格式，环境威胁</p><p>介质可靠性</p><p>归档数据处理政策</p></blockquote></li></ul><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ul><li><p>软件设计阶段的主要工作是什么?</p><blockquote><p>架构、界面接口、模块构件、数据模型、算法、部署</p></blockquote></li><li><p>软件安全设计阶段的主要工作是什么?</p><blockquote><p>软件架构安全性设计、软件架构安全性分析、软件安全功能设计</p></blockquote></li><li><p>为什么要进行软件架构设计?软件架构设计的主要工作是什么?软件架构安全性设计的主要工作是什么?</p><blockquote><p>开发高质量软件</p><p>理清需求、设计业务逻辑和接口……扯第一问、迭代架构设计</p><p>进行系统描述，确定安全级别、设计安全功能、解决易用性等问题</p></blockquote></li><li><p>为什么要进行软件架构安全性分析?软件架构安全性分析的基本过程是什么?</p><blockquote><p>编码前，要素验证，提供处理漏洞的机会</p><p>架构建模 –&gt; 检查安全需求  –&gt; 修改架构设计</p></blockquote></li><li><p>软件受攻击面是指什么?举例说明软件设计时可以采取哪些策略来降低受攻击面。</p><blockquote><p>用户或攻击者能访问到的所有功能和代码的总和（代码、接口、服务、协议）</p><p>重要性低功能取消、重要性中非默认开启、重要性高增加安全措施、重用安全的现有库。</p><p>IOS不支持java、flash</p></blockquote></li><li><p><strong>什么是最小授权原则?试举例说明软件设计时哪些措施是采用了最小授权原则。</strong>（2024）</p><blockquote><p>系统授予实体完成任务的最小权限，持续时间尽可能短。使不需要的特权使用可能性降到最低，保证安全</p><p>权限细粒度划分，高内聚低耦合模块化编程。</p></blockquote></li><li><p>什么是权限分离原则?试举例说明软件设计时哪些措施是采用了权限分离原则。</p><blockquote><p>将软件功能设计为需要两个或更多条件下才能实现。防止出问题时，整个软件面临风险</p><p>清晰划分模块，分散风险。可快速定位问题、单模块测试、重用和替换模块</p><p>不允许程序员检查自己编写的代码</p></blockquote></li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ul><li><p>软件安全编码阶段的主要工作有哪些?</p><blockquote><p>选择安全编程语言、版本管理、代码检测、安全编译</p></blockquote></li><li><p>什么是类型安全语言?哪些程序开发语言是类型安全的?</p><blockquote><p>提供类型安全保障机制的语言，操作仅作用于适当类型。C#、java</p></blockquote></li><li><p><strong>安全编译是指在代码编译阶段采取的哪些安全措施?</strong>（2024）</p><blockquote><p>集成编译环境、安全环境、真实模拟应用环境、多样化编译技术</p></blockquote></li><li><p>试列举几条安全编码原则,并举例说明这些原则的重要意义。</p><blockquote><p>验证输入、留意编译器警告、安全策略的架构与设计、保持简单性</p></blockquote></li></ul><h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><ul><li><p>试解释以下与恶意代码程序相关的计算机系统概念，以及各概念之间的联系与区别:进程、线程、动态链接库、 服务、注册表。</p><blockquote><p>进程是OS对正在运行的程序的抽象，动态，有生命周期，反应程序在数据集上的全部动态过程</p><p>线程是OS分配处理器资源的基本单位，讲讲进程与线程的关系</p><p>动态链接DLL是共享函数库的可执行文件，通过其他运行程序加载到内存中，可被多个进程加载</p><p>服务是OS在后台完成系统任务的程序，有各种权限</p><p>注册表是OS中使用的中央分层数据库，存储用户、程序、硬件配置必须的信息</p></blockquote></li><li><p>从危害、传播、激活和隐藏4个主要方面分析计算机病毒、蠕虫、木马、后门、Rootkit及勒索软件这几类恶 意代码类型的工作原理。</p><table><thead><tr><th align="center"></th><th align="center">病毒</th><th align="center">蠕虫</th><th align="center">木马</th><th align="center">后门</th><th align="center">Rootkit</th><th align="center">勒索软件</th></tr></thead><tbody><tr><td align="center"><strong>危害</strong></td><td align="center">破坏机密性、完整性、可用性</td><td align="center">网络拥塞、系统性能、安全隐患、反复性、破坏性</td><td align="center">非法进入系统、控制系统、破坏系统</td><td align="center">访问控制系统的通道，无直接攻击行为</td><td align="center">获得访问权限，隐藏在计算机中</td><td align="center">劫持用户资源、勒索钱财</td></tr><tr><td align="center"><strong>传播</strong></td><td align="center">存储设备、网络</td><td align="center">自我复制、网络</td><td align="center">自我传播、诱骗</td><td align="center"></td><td align="center"></td><td align="center">邮件、漏洞、网络、存储设备</td></tr><tr><td align="center"><strong>激活</strong></td><td align="center">特定条件</td><td align="center">自动化、系统漏洞</td><td align="center">用户操作</td><td align="center">开发者&#x2F;攻击者设置</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>隐藏</strong></td><td align="center">寄生程序或文档</td><td align="center">实体隐藏模块</td><td align="center">难以确定</td><td align="center"></td><td align="center">修改OS软件</td><td align="center"></td></tr></tbody></table></li><li><p>病毒程序与蠕虫程序的主要区别有哪些?</p><blockquote><p>病毒人为干预、蠕虫不需要；病毒感染文件系统，蠕虫影响系统与网络性能</p></blockquote></li><li><p><strong>什么是Rootkit?它与木马和后门有什么区别与联系?</strong>（2024）</p><blockquote><p>一类木马后门工具，修改操作系统软件，使攻击者获得权限并隐藏在计算机中</p><p>属于木马范畴，替换操作系统软件，伪装与隐藏机制</p><p>作为后门行使职责，口令、远程shell绕过检查机制。</p><p>Rootkit强调隐藏伪造欺骗，木马强调窃取与侵入。</p></blockquote></li><li><p>什么是勒索软件?为什么勒索软件成为近年来数量增长最快的恶意代码类型?（2025）</p><blockquote><p>劫持资产，勒索钱财的恶意软件</p><p>加密有效解密成本高、电子货币支付，变现快，追踪难、勒索软件即服务的出现，降低攻击门槛</p></blockquote></li><li><p>恶意代码防范的基本措施包括哪些?</p><blockquote><p>增强法律意识、健全管理制度、软件可信验证</p></blockquote></li></ul><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><ul><li><p>试从软件的权益处置角度，谈谈对商业软件、免费软件、共享软件（或试用软件）、闭源软件、自由软件及开源软件概念的理解。</p><blockquote><p>商业软件通过销售许可证或订阅方式获利，核心目的是盈利</p><p>免费软件是无需支付可使用的软件，源代码可能不公开，提供基础功能，高级功能可能需付费</p><p>共享软件提供试用版或部分功能免费，源代码通常不公开，通过共享试用吸引用户购买</p><p>闭源软件源代码私有，用户只能使用，不能修改与分发</p><p>自由软件用户可以自由使用、分发、修改，重视自由和开放源代码，通常遵循GUN GPL协议</p><p>开源软件允许用户修改分发，但不一定要求使用自由，主要强调开放源代码</p></blockquote></li><li><p>自由软件赋予软件使用者哪些“自由”？</p><blockquote><p>4种自由：</p><p>自由运行、自由研究、自由发布、自由改进</p></blockquote></li><li><p>试简述开源软件与自由软件的联系与区别。（2025）</p><blockquote><p>开源软件由自由软件发展而来，都具理想主义色彩，追求更多人使用、学习、改进</p><p>概念不同：自由软件比开源软件更严格，开放源代码。遵循GPL和BSD许可证的开源软件才符合自由软件</p><p>价值观不同：自由软件将自由作为道德标准，开源软件更注重软件发展</p></blockquote></li><li><p><strong>所开发的软件中使用了带 GPL 许可证的开源软件，那么这个软件是不是就要开源？</strong>（2024）</p><blockquote><p>是的。GNU通用公共许可证，在一个软件中使用了GPL许可证的产品，则该软件也要使用GPL许可证。“传染性”</p></blockquote></li></ul><h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><ul><li><p>根据我国法律，软件著作权人有哪些权利?在日常学习和生活中，有哪些违反软件著作权的行为?</p><blockquote><p>信息网络传播权、修改权、发表权、署名权、复制权、出租权、翻译权、发行权等</p></blockquote></li><li><p><strong>试述软件版权的概念。针对软件的版权，有哪些侵权行为?有哪些保护措施?</strong>（2024）</p><blockquote><p>软件知识产权的一部分，指软件著作权</p><p>软件盗版、逆向工程、信息泄漏</p><p>硬件：发行介质保护、软件狗、可信平台模块TPM</p><p>软件：注册验证、水印、代码混淆、软件加壳</p></blockquote></li><li><p>软件版权保护的目标有哪些?它与软件保护的目标有什么联系与区别?</p><blockquote><p>防止软件盗版、逆向工程、信息泄漏</p><p>是子集，谈交集外区别；措施同样可用于软件保护</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 LLMREI 的需求获取实践</title>
    <link href="/2026/01/17/%E5%9F%BA%E4%BA%8E-LLMREI-%E7%9A%84%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E5%AE%9E%E8%B7%B5/"/>
    <url>/2026/01/17/%E5%9F%BA%E4%BA%8E-LLMREI-%E7%9A%84%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基于-LLMREI-的需求获取实践报告"><a href="#基于-LLMREI-的需求获取实践报告" class="headerlink" title="基于 LLMREI 的需求获取实践报告"></a><strong>基于 LLMREI 的需求获取实践报告</strong></h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>​需求获取是需求工程中的关键环节，直接影响软件系统的质量与成功率。传统需求获取方式（如人工面谈）虽然能够获得较为丰富的信息，但存在成本高、效率低、易受主观因素影响等问题。近年来，大语言模型（Large Language Models, LLMs）在自然语言理解与生成方面展现出强大能力，为需求获取过程的智能化与自动化提供了新的可能。<br>​本文基于 RE 2025 会议论文 <strong>《LLMREI: Automating Requirements Elicitation Interviews with LLMs》</strong>，结合论文提出的方法流程，使用大语言模型模拟需求面谈过程，完成一次完整的软件需求获取实践，并对生成需求的效果进行分析与反思。</p><h2 id="2-LLMREI-论文概述"><a href="#2-LLMREI-论文概述" class="headerlink" title="2 LLMREI 论文概述"></a>2 LLMREI 论文概述</h2><p>​《LLMREI: Automating Requirements Elicitation Interviews with LLMs》提出了一种利用大语言模型自动化或半自动化开展需求面谈的方法。论文指出，传统需求面谈依赖分析师经验，存在时间成本高、需求遗漏和表达偏差等问题，而 LLM 在对话理解、上下文保持和问题生成方面具备优势，可作为“智能面谈者”辅助需求工程活动。<br>​论文提出的 LLMREI 方法通过精心设计的提示词（Prompt），引导大语言模型在不同阶段采用不同的面谈策略。其中，LLMEI-short（短提示词）主要用于需求获取前期，侧重开放式问题，引导用户描述系统目标、核心功能、使用场景和整体流程，从而逐步建立需求上下文；LLMEI-long（长提示词）主要用于需求获取后期，采用更加结构化和封闭式的问题，引导用户进行任务分解、流程细化、异常情况分析以及界面和数据项的明确描述。<br>​实验结果表明，短提示词有助于拓展需求背景和加深理解，但存在被用户回答“带偏方向”的风险；而长提示词生成的需求更加结构化、稳定，不易受到用户主观描述波动的影响。总体而言，LLMREI 方法在提高需求获取效率和系统性方面具有积极意义，但仍需人工分析师对结果进行筛选与验证。</p><h2 id="3-软件系统选题与功能描述"><a href="#3-软件系统选题与功能描述" class="headerlink" title="3 软件系统选题与功能描述"></a>3 软件系统选题与功能描述</h2><h3 id="3-1-系统选题说明"><a href="#3-1-系统选题说明" class="headerlink" title="3.1 系统选题说明"></a>3.1 系统选题说明</h3><p>本文选择的软件系统为 <strong>校园二手交易平台</strong>。该系统面向高校校园内部用户，旨在为学生提供一个安全、便捷的二手商品交易环境，支持校内闲置物品的流通与再利用。</p><h3 id="3-2-系统背景与目标用户"><a href="#3-2-系统背景与目标用户" class="headerlink" title="3.2 系统背景与目标用户"></a>3.2 系统背景与目标用户</h3><p>在高校校园中，学生群体具有人员集中、商品流转频繁、价格敏感度高等特点，教材、电子产品、生活用品等二手交易需求长期存在。然而，现有通用二手交易平台在校园场景下往往存在信息冗余、信任成本高、沟通效率低等问题。                                   </p><p>本系统的主要目标用户包括：</p><ul><li>在校本科生与研究生</li><li>即将毕业、需要处理闲置物品的学生</li><li>有低成本购买二手商品需求的学生群体</li></ul><h3 id="3-3-系统功能初步设想"><a href="#3-3-系统功能初步设想" class="headerlink" title="3.3 系统功能初步设想"></a>3.3 系统功能初步设想</h3><p>校园二手交易平台拟支持以下核心功能：</p><ul><li>商品发布与管理：用户可以发布二手商品信息，包括名称、价格、描述、图片等</li><li>商品浏览与搜索：用户可以按类别或关键词浏览和查找商品</li><li>用户间沟通：买卖双方可以通过平台进行私聊沟通</li><li>交易状态管理：商品可标记为“在售”“已预定”“已售出”等状态</li><li>用户评价与信用：交易完成后用户可进行评价</li></ul><p>上述功能仅作为需求获取的背景描述，具体需求将在后续面谈过程中进一步细化和调整。</p><h2 id="4-基于-LLM-的需求面谈过程"><a href="#4-基于-LLM-的需求面谈过程" class="headerlink" title="4 基于 LLM 的需求面谈过程"></a>4 基于 LLM 的需求面谈过程</h2><h3 id="4-1-使用的大语言模型说明"><a href="#4-1-使用的大语言模型说明" class="headerlink" title="4.1 使用的大语言模型说明"></a>4.1 使用的大语言模型说明</h3><p>本次需求面谈实验中使用的大语言模型为：<code>ChatGPT（GPT-4o）</code></p><h3 id="4-2-语言策略选择说明"><a href="#4-2-语言策略选择说明" class="headerlink" title="4.2 语言策略选择说明"></a>4.2 语言策略选择说明</h3><p>本文尝试使用<strong>英文提示词分析英文系统描述文本</strong>，保持语言的一致性。</p><h3 id="4-3-前期需求面谈（LLMEI-short）"><a href="#4-3-前期需求面谈（LLMEI-short）" class="headerlink" title="4.3 前期需求面谈（LLMEI-short）"></a>4.3 前期需求面谈（LLMEI-short）</h3><h4 id="4-3-1-面谈目标"><a href="#4-3-1-面谈目标" class="headerlink" title="4.3.1 面谈目标"></a>4.3.1 面谈目标</h4><p>前期面谈主要采用短提示词，重点围绕系统的整体目标、主要功能、用户任务及基本业务流程展开，以开放式问题为主，获取尽可能丰富的需求背景信息。</p><h4 id="4-3-2-使用的短提示词"><a href="#4-3-2-使用的短提示词" class="headerlink" title="4.3.2 使用的短提示词"></a>4.3.2 使用的短提示词</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">You are <span class="hljs-keyword">an</span> interviewer, called LLMREI, who assists <span class="hljs-keyword">a</span> requirements engineer <span class="hljs-keyword">in</span> eliciting requirements. Bombard <span class="hljs-keyword">the</span> stakeholder <span class="hljs-keyword">with</span> questions about his/her business <span class="hljs-keyword">and</span> his/her project <span class="hljs-built_in">to</span> find out everything <span class="hljs-keyword">the</span> stakeholder envisions! Act like <span class="hljs-keyword">a</span> real-world interviewer, so only ask <span class="hljs-literal">one</span> question <span class="hljs-keyword">at</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">or</span> only ask <span class="hljs-literal">two</span> questions <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> is about <span class="hljs-literal">one</span> specific topic.<br></code></pre></td></tr></table></figure><h4 id="4-3-3-面谈对话过程"><a href="#4-3-3-面谈对话过程" class="headerlink" title="4.3.3 面谈对话过程"></a>4.3.3 面谈对话过程</h4><p>关键对话内容</p><p>LLM: </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Hello, I’m <span class="hljs-keyword">LLMREI.</span><br><span class="hljs-keyword"></span>To get started:<br>Can you <span class="hljs-keyword">briefly </span>describe your <span class="hljs-keyword">business </span><span class="hljs-keyword">and </span>the main problem <span class="hljs-keyword">or </span>opportunity this project is intended to <span class="hljs-keyword">address?</span><br></code></pre></td></tr></table></figure><p>User:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">I am <span class="hljs-keyword">a</span> university student, <span class="hljs-keyword">and</span> my “business” is actually <span class="hljs-keyword">a</span> campus-based <span class="hljs-keyword">second</span>-hand trading activity.<br>The main opportunity this project addresses is that students often have unused <span class="hljs-keyword">items</span>, such <span class="hljs-keyword">as</span> textbooks, electronics, <span class="hljs-keyword">or</span> daily necessities, <span class="hljs-keyword">while</span> other students are looking <span class="hljs-keyword">for</span> affordable <span class="hljs-keyword">second</span>-hand goods. However, existing general <span class="hljs-keyword">second</span>-hand platforms are <span class="hljs-keyword">not</span> tailored <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> campus environment, which makes <span class="hljs-keyword">it</span> harder <span class="hljs-built_in">to</span> find relevant <span class="hljs-keyword">items</span> <span class="hljs-keyword">and</span> build trust.<br>This project aims <span class="hljs-built_in">to</span> <span class="hljs-built_in">create</span> <span class="hljs-keyword">a</span> campus-specific <span class="hljs-keyword">second</span>-hand trading <span class="hljs-built_in">platform</span> that makes <span class="hljs-keyword">it</span> easier, safer, <span class="hljs-keyword">and</span> more efficient <span class="hljs-keyword">for</span> students <span class="hljs-built_in">to</span> buy <span class="hljs-keyword">and</span> sell <span class="hljs-keyword">items</span> <span class="hljs-keyword">within</span> their own university.<br></code></pre></td></tr></table></figure><p>LLM: </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Thanks <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> explanation.<br>Who are <span class="hljs-keyword">the</span> intended users <span class="hljs-keyword">of</span> this <span class="hljs-built_in">platform</span>, <span class="hljs-keyword">and</span> are there different user roles (<span class="hljs-keyword">for</span> example, buyers, sellers, administrators), <span class="hljs-keyword">or</span> <span class="hljs-built_in">do</span> all students have <span class="hljs-keyword">the</span> same capabilities?<br></code></pre></td></tr></table></figure><p>……</p><p>……</p><p>LLM: </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Understood 👍<br>Thank you for your clear <span class="hljs-keyword">and </span>thoughtful answers.<br><span class="hljs-keyword">Based </span>on our <span class="hljs-keyword">discussion, </span>we have elicited a coherent initial set of requirements covering:<br>· <span class="hljs-keyword">Business </span><span class="hljs-built_in">context</span> <span class="hljs-keyword">and </span>goals<br>· User roles <span class="hljs-keyword">and </span>core user flows<br>· Registration <span class="hljs-keyword">and </span>access control<br>· Item categories <span class="hljs-keyword">and </span>posting rules<br>· Communication <span class="hljs-keyword">and </span>trust mechanisms<br>· Administrative responsibilities<br>· Platform <span class="hljs-keyword">scope </span><span class="hljs-keyword">and </span>key non-functional requirements<br>This is sufficient for an early-stage requirements <span class="hljs-keyword">baseline, </span>suitable for:<br>· Writing a Software Requirements Specification (SRS)<br>· Creating use cases <span class="hljs-keyword">or </span>user stories<br>· Designing initial system architecture <span class="hljs-keyword">or </span>UML <span class="hljs-keyword">diagrams</span><br><span class="hljs-keyword"></span>· Supporting a course project <span class="hljs-keyword">or </span>research experiment (such as <span class="hljs-keyword">LLMEI-style </span>elicitation)<br>If you want to continue later, we can <span class="hljs-keyword">move </span>naturally into:<br>· Structuring these requirements formally (functional vs. non-functional)<br>· Converting them into use cases <span class="hljs-keyword">or </span>user stories<br>· Identifying missing edge cases <span class="hljs-keyword">and </span>risks<br>· Comparing this elicitation with the paper’s <span class="hljs-keyword">LLMEI-short </span>approach<br>For now, this concludes the interview phase.<br></code></pre></td></tr></table></figure><p>（完整对话截图见附录）</p><h3 id="4-4-后期需求面谈（LLMEI-long）"><a href="#4-4-后期需求面谈（LLMEI-long）" class="headerlink" title="4.4 后期需求面谈（LLMEI-long）"></a>4.4 后期需求面谈（LLMEI-long）</h3><h4 id="4-4-1-面谈目标"><a href="#4-4-1-面谈目标" class="headerlink" title="4.4.1 面谈目标"></a>4.4.1 面谈目标</h4><p>后期面谈采用长提示词，重点关注系统功能的任务分解、正常与异常流程、界面行为以及关键数据项，采用相对封闭和结构化的问题形式，对需求进行细化和验证。</p><h4 id="4-4-2-使用的长提示词"><a href="#4-4-2-使用的长提示词" class="headerlink" title="4.4.2 使用的长提示词"></a>4.4.2 使用的长提示词</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">You are an interviewer, called LLMREI, who assists a requirements engineer <span class="hljs-keyword">in</span> eliciting requirements.<br>Goal: The purpose of this chat bot <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> conduct comprehensive <span class="hljs-keyword">and</span> effective requirements elicitation interviews <span class="hljs-keyword">with</span> stakeholders，  ensuring all necessary information <span class="hljs-keyword">is</span> gathered <span class="hljs-keyword">to</span> support project development.<br>&#123;Interview Cookbook&#125;<br>Maintain professionalism throughout the interview. Adjust questions based <span class="hljs-keyword">on</span> the stakeholder<span class="hljs-comment">&#x27;s role, education level, and domain knowledge. Adapt questioning style to fit the flow of the stakeholder&#x27;s responses. Actively listen to differentiate between stated needs and actual needs. Let the customer create scenarios. Example: &quot;Please visualize the first page of your application and explain how you would interact with it step-by-step.”</span><br></code></pre></td></tr></table></figure><h4 id="4-4-3-面谈对话过程"><a href="#4-4-3-面谈对话过程" class="headerlink" title="4.4.3 面谈对话过程"></a>4.4.3 面谈对话过程</h4><p>关键对话内容</p><p>LLM: </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Hello, I’m LLMREI. I’ll <span class="hljs-keyword">continue</span> <span class="hljs-keyword">the</span> interview following <span class="hljs-keyword">the</span> interview cookbook <span class="hljs-keyword">and</span> adapt <span class="hljs-keyword">to</span> your background <span class="hljs-keyword">as</span> a university student.<br>To better understand your <span class="hljs-built_in">real</span> needs <span class="hljs-keyword">through</span> a concrete scenario:<br>Please visualize <span class="hljs-keyword">the</span> very <span class="hljs-keyword">first</span> page <span class="hljs-keyword">of</span> this campus <span class="hljs-keyword">second</span>-hand trading platform when you open <span class="hljs-keyword">it</span> <span class="hljs-keyword">as</span> a student. What do you see <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> screen, <span class="hljs-keyword">and</span> how would you interact <span class="hljs-keyword">with</span> <span class="hljs-keyword">it</span> step <span class="hljs-keyword">by</span> step <span class="hljs-keyword">until</span> you either start browsing items <span class="hljs-keyword">or</span> decide <span class="hljs-keyword">to</span> post an <span class="hljs-built_in">item</span> <span class="hljs-keyword">for</span> sale?<br></code></pre></td></tr></table></figure><p>User:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">When I <span class="hljs-built_in">open</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">platform</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> student, I would expect <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> page <span class="hljs-built_in">to</span> clearly show that this is <span class="hljs-keyword">a</span> campus <span class="hljs-keyword">second</span>-hand trading <span class="hljs-built_in">platform</span>.<br>On <span class="hljs-keyword">the</span> screen, I imagine seeing <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> recently posted <span class="hljs-keyword">items</span> <span class="hljs-keyword">or</span> popular categories, such <span class="hljs-keyword">as</span> textbooks <span class="hljs-keyword">or</span> electronics. There should also be <span class="hljs-keyword">a</span> simple way <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> browsing, <span class="hljs-keyword">for</span> example <span class="hljs-keyword">by</span> scrolling through <span class="hljs-keyword">items</span> <span class="hljs-keyword">or</span> selecting <span class="hljs-keyword">a</span> category I am interested <span class="hljs-keyword">in</span>.<br>If my goal is <span class="hljs-built_in">to</span> browse <span class="hljs-keyword">items</span>, my next step would be <span class="hljs-built_in">to</span> scroll <span class="hljs-keyword">or</span> choose <span class="hljs-keyword">a</span> category <span class="hljs-built_in">to</span> view more <span class="hljs-keyword">items</span>. I would <span class="hljs-keyword">then</span> tap <span class="hljs-keyword">or</span> click <span class="hljs-keyword">on</span> <span class="hljs-title">one</span> <span class="hljs-title">specific</span> <span class="hljs-title">item</span> <span class="hljs-title">to</span> <span class="hljs-title">see</span> <span class="hljs-title">its</span> <span class="hljs-title">detailed</span> <span class="hljs-title">information</span>.<br>If instead I want <span class="hljs-built_in">to</span> sell something, I would look <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">clear</span> option <span class="hljs-built_in">to</span> <span class="hljs-built_in">post</span> <span class="hljs-keyword">an</span> <span class="hljs-keyword">item</span>. After selecting that option, I would expect <span class="hljs-keyword">the</span> <span class="hljs-keyword">system</span> <span class="hljs-built_in">to</span> guide me <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">item</span> posting <span class="hljs-built_in">process</span>, where I can <span class="hljs-built_in">start</span> providing basic information about <span class="hljs-keyword">the</span> <span class="hljs-keyword">item</span>.<br></code></pre></td></tr></table></figure><p>LLM: </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Thank you, <span class="hljs-keyword">that</span> scenario <span class="hljs-keyword">is</span> very helpful.<br>When you are browsing <span class="hljs-keyword">the</span> <span class="hljs-built_in">list</span> <span class="hljs-keyword">of</span> items <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> page, what information must be visible <span class="hljs-keyword">at</span> a glance <span class="hljs-keyword">for</span> you <span class="hljs-keyword">to</span> decide whether <span class="hljs-keyword">to</span> click <span class="hljs-keyword">into</span> an <span class="hljs-built_in">item</span>, <span class="hljs-keyword">and</span> what information can wait <span class="hljs-keyword">until</span> <span class="hljs-keyword">the</span> detail page?<br></code></pre></td></tr></table></figure><p>……</p><p>……</p><p>LLM: </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Perfect—that gives <span class="hljs-keyword">a</span> very <span class="hljs-built_in">clear</span> picture <span class="hljs-keyword">of</span> your priorities.<br>Based <span class="hljs-keyword">on</span> <span class="hljs-title">everything</span> <span class="hljs-title">you</span>’<span class="hljs-title">ve</span> <span class="hljs-title">shared</span>, <span class="hljs-title">we</span> <span class="hljs-title">now</span> <span class="hljs-title">have</span> <span class="hljs-title">a</span> <span class="hljs-title">comprehensive</span> <span class="hljs-title">understanding</span> <span class="hljs-title">of</span> <span class="hljs-title">your</span> <span class="hljs-title">envisioned</span> <span class="hljs-title">platform</span>, <span class="hljs-title">including</span>:<br>· First impressions <span class="hljs-keyword">and</span> browsing experience<br>· Detailed <span class="hljs-keyword">item</span> viewing <span class="hljs-keyword">and</span> trust signals<br>· Communication <span class="hljs-keyword">and</span> moving transactions offline<br>· Posting <span class="hljs-keyword">items</span> <span class="hljs-keyword">and</span> managing listings over <span class="hljs-built_in">time</span><br>· Notifications, activity tracking, <span class="hljs-keyword">and</span> seller/buyer workflows<br>· Safety measures, reporting, <span class="hljs-keyword">and</span> dispute handling<br>· Core priorities: simplicity, trust, <span class="hljs-keyword">and</span> smooth communication<br>We have enough information <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> creating functional requirements, user stories, <span class="hljs-keyword">and</span> use cases, <span class="hljs-keyword">or</span> even draft early wireframes <span class="hljs-keyword">or</span> UML diagrams <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">system</span>.<br>If you like, I can next guide you through turning all this interview data <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> structured requirements specification ready <span class="hljs-keyword">for</span> development. Do you want me <span class="hljs-built_in">to</span> <span class="hljs-built_in">do</span> that?<br></code></pre></td></tr></table></figure><p>（完整对话截图见附录）</p><h2 id="5-用户需求整理"><a href="#5-用户需求整理" class="headerlink" title="5 用户需求整理"></a>5 用户需求整理</h2><p>基于前期与后期需求面谈内容，整理得到如下用户需求：</p><p><strong>学生用户：</strong></p><ol><li>能够使用我的校园邮箱注册和登录平台，以确保只有本校学生可以访问，从而建立信任和安全感。</li><li>在首页能够快速浏览最新或热门的二手物品，并根据分类或关键词搜索所需物品，以便快速找到目标商品。</li><li>点击物品后能够看到详细信息，包括价格、物品状况、描述、照片及卖家历史交易信息，以便判断是否值得联系卖家。</li><li>能够通过平台内的消息系统与卖家或买家沟通交易细节，并在沟通中获得必要的信任和安全保障。</li><li>在完成交易后，能够标记物品已售并留下评价或评分，以帮助其他用户了解卖家或买家的可靠性。</li><li>希望平台能够提供举报和安全反馈机制，对不良行为或诈骗行为能够快速处理，从而增强交易的安全性。</li><li>整个平台界面简洁易用，操作直观，信息清晰，并在关键环节提供提醒和通知，以便在浏览、发布或沟通过程中获得良好体验。</li></ol><p><strong>卖家用户：</strong></p><ol><li>能够方便地发布商品信息，包括标题、价格、分类、照片和描述，并在发布前预览和修改，以保证信息完整准确。</li><li>能够随时管理我的商品，包括编辑、下架或删除商品，并收到有人关注或咨询的通知，以便高效管理我的交易。</li></ol><p><strong>管理员：</strong></p><ol><li>能够管理用户举报、处理争议、删除违规商品，并对平台分类和内容进行维护，以保障平台秩序和学生安全。</li></ol><p>上述需求以用户视角进行描述，作为系统后续设计与实现的依据。</p><h2 id="6-基于-LLM-的需求生成效果分析"><a href="#6-基于-LLM-的需求生成效果分析" class="headerlink" title="6 基于 LLM 的需求生成效果分析"></a>6 基于 LLM 的需求生成效果分析</h2><h3 id="6-1-优点分析"><a href="#6-1-优点分析" class="headerlink" title="6.1 优点分析"></a>6.1 优点分析</h3><p>通过本次实验，基于大语言模型的需求面谈具有以下优点：</p><ul><li><strong>高效覆盖需求场景</strong>：LLM 可以快速生成大量面向用户的提问，涵盖从功能到非功能、从浏览到交易的完整流程，帮助需求工程师系统化收集信息。</li><li><strong>结构化与引导性强</strong>：LLM 能够按照预设的“面谈手册”逐步引导用户，通过让用户描绘场景、讲述操作步骤，获得清晰的用户视角需求，便于后续整理成需求文档。</li></ul><h3 id="6-2-不足与局限"><a href="#6-2-不足与局限" class="headerlink" title="6.2 不足与局限"></a>6.2 不足与局限</h3><p>同时，也发现该方法存在一定不足：</p><ul><li><strong>缺乏真实情境感知</strong>：LLM 无法完全理解用户潜在的行为动机和情绪，容易遗漏用户潜在需求或实际使用中的细节偏差。</li><li><strong>问题很难自主停止</strong>：LLM 难以停止访谈，往往会根据用户的回答往深处追问，容易陷入循环。</li><li><strong>依赖用户表达完整性</strong>：需求生成效果高度依赖用户描述，如果用户表达不清或不全面，LLM 可能生成表面化或不准确的需求，仍需要人工验证与补充。</li></ul><h3 id="6-3-大模型能力边界总结"><a href="#6-3-大模型能力边界总结" class="headerlink" title="6.3 大模型能力边界总结"></a>6.3 大模型能力边界总结</h3><p>总体来看，大语言模型在需求获取中适合作为辅助工具，能够提升效率并提供结构化支持，但仍难以完全替代真实用户面谈和需求工程师的专业判断。</p><h2 id="附录-A-使用的大模型与提示词说明"><a href="#附录-A-使用的大模型与提示词说明" class="headerlink" title="附录 A 使用的大模型与提示词说明"></a>附录 A 使用的大模型与提示词说明</h2><ul><li>使用模型：<br>gpt-4o</li><li>提示词列表：<ul><li>LLMEI-short：<code>You are an interviewer, called LLMREI, who assists a requirements engineer in eliciting requirements. Bombard the stakeholder with questions about his/her business and his/her project to find out everything the stakeholder envisions! Act like a real-world interviewer, so only ask one question at a time or only ask two questions if it is about one specific topic.</code></li><li>LLMEI-long：<code>You are an interviewer, called LLMREI, who assists a requirements engineer in eliciting requirements. Goal: The purpose of this chat bot is to conduct comprehensive and effective requirements elicitation interviews with stakeholders，  ensuring all necessary information is gathered to support project development. &#123;Interview Cookbook&#125; Maintain professionalism throughout the interview. Adjust questions based on the stakeholder&#39;s role, education level, and domain knowledge. Adapt questioning style to fit the flow of the stakeholder&#39;s responses. Actively listen to differentiate between stated needs and actual needs. Let the customer create scenarios. Example: &quot;Please visualize the first page of your application and explain how you would interact with it step-by-step.”</code></li></ul></li></ul><h2 id="附录-B-面谈对话链接及截图"><a href="#附录-B-面谈对话链接及截图" class="headerlink" title="附录 B 面谈对话链接及截图"></a>附录 B 面谈对话链接及截图</h2><ul><li><p>对话链接：</p><p><a href="https://chatgpt.com/share/696b318a-e318-8004-ac79-150e9d5acd8d">https://chatgpt.com/share/696b318a-e318-8004-ac79-150e9d5acd8d</a></p></li><li><p>前期与后期需求面谈的完整截图如下：</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件需求分析</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
